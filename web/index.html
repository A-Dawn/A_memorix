<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>A_Memorix | çŸ¥è¯†å…¨æ™¯å›¾</title>
    <!-- Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&display=swap"
      rel="stylesheet"
    />
    <!-- Vis.js & Axios -->
    <script
      type="text/javascript"
      src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"
    ></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <style>
      :root {
        --bg-color: #0f172a;
        --glass-bg: rgba(30, 41, 59, 0.7);
        --glass-border: rgba(255, 255, 255, 0.1);
        --accent-primary: #38bdf8;
        --accent-secondary: #818cf8;
        --text-main: #f1f5f9;
        --text-dim: #94a3b8;
        --danger: #ef4444;
        --success: #10b981;
        --warning: #f59e0b;
      }

      :root[data-theme="light"] {
        --bg-color: #f8fafc;
        --glass-bg: rgba(255, 255, 255, 0.75);
        --glass-border: rgba(0, 0, 0, 0.1);
        --accent-primary: #0284c7;
        /* Sky 600 */
        --accent-secondary: #6366f1;
        /* Indigo 500 */
        --text-main: #1e293b;
        --text-dim: #64748b;
      }

      :root[data-theme="neon"] {
        --bg-color: #13001f;
        /* Deep Purple */
        --glass-bg: rgba(40, 0, 60, 0.6);
        --glass-border: rgba(217, 70, 239, 0.3);
        /* Pink border */
        --accent-primary: #d946ef;
        /* Fuchsia */
        --accent-secondary: #8b5cf6;
        /* Violet */
        --text-main: #e9d5ff;
        --text-dim: #a78bfa;
      }

      body {
        font-family: "Outfit", "Segoe UI", system-ui, sans-serif;
        margin: 0;
        padding: 0;
        height: 100vh;
        overflow: hidden;
        background-color: var(--bg-color);
        color: var(--text-main);
        background-image:
          radial-gradient(
            circle at 10% 20%,
            rgba(56, 189, 248, 0.05) 0%,
            transparent 40%
          ),
          radial-gradient(
            circle at 90% 80%,
            rgba(129, 140, 248, 0.05) 0%,
            transparent 40%
          );
      }

      /* Loading Overlay */
      #loader {
        position: fixed;
        inset: 0;
        background: var(--bg-color);
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        backdrop-filter: blur(10px);
      }

      #loader.sync-mode {
        background: rgba(15, 23, 42, 0.6);
      }

      .spinner {
        width: 48px;
        height: 48px;
        border: 3px solid rgba(56, 189, 248, 0.1);
        border-top: 3px solid var(--accent-primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        box-shadow: 0 0 20px rgba(56, 189, 248, 0.2);
      }

      .loader-text {
        margin-top: 24px;
        color: var(--text-main);
        font-size: 1rem;
        font-weight: 500;
        letter-spacing: 0.05em;
        animation: loaderPulse 2s infinite ease-in-out;
      }

      @keyframes loaderPulse {
        0%, 100% { opacity: 0.6; transform: scale(1); }
        50% { opacity: 1; transform: scale(1.02); }
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* Container */
      #container {
        width: 100%;
        height: 100vh;
        background-color: transparent;
      }

      /* Floating Search */
      .search-container {
        position: absolute;
        top: 24px;
        left: 24px;
        z-index: 100;
        display: flex;
        gap: 8px;
        backdrop-filter: blur(12px);
        background: var(--glass-bg);
        padding: 6px;
        border-radius: 12px;
        border: 1px solid var(--glass-border);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }

      .search-container input {
        background: transparent;
        border: none;
        color: white;
        padding: 8px 12px;
        outline: none;
        width: 200px;
        font-size: 0.9rem;
      }

      .search-container button {
        background: var(--accent-primary);
        border: none;
        color: var(--bg-color);
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        transition: transform 0.2s;
      }

      .search-container button:hover {
        transform: scale(1.05);
      }

      /* Bottom Dock */
      .dock {
        position: absolute;
        bottom: 32px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 100;
        display: flex;
        align-items: center;
        gap: 12px;
        backdrop-filter: blur(16px);
        background: var(--glass-bg);
        padding: 12px 24px;
        border-radius: 24px;
        border: 1px solid var(--glass-border);
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      }

      .dock-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
        cursor: pointer;
        padding: 8px;
        border-radius: 12px;
        transition: all 0.2s;
        color: var(--text-dim);
        min-width: 60px;
      }

      .dock-btn:hover {
        background: rgba(255, 255, 255, 0.05);
        color: var(--accent-primary);
        transform: translateY(-4px);
      }

      .dock-btn.active {
        color: var(--accent-primary);
      }

      .dock-btn span {
        font-size: 0.7rem;
        font-weight: 600;
      }

      .dock-icon {
        font-size: 1.2rem;
      }

      .divider {
        width: 1px;
        height: 30px;
        background: var(--glass-border);
        margin: 0 8px;
      }

      /* Side Panel (Glassmorphism) */
      .side-panel {
        position: absolute;
        top: 24px;
        right: 24px;
        width: 360px;
        max-height: calc(100vh - 120px);
        z-index: 100;
        backdrop-filter: blur(20px);
        background: var(--glass-bg);
        border: 1px solid var(--glass-border);
        border-radius: 20px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        display: none;
        flex-direction: column;
        overflow: hidden;
        animation: slideIn 0.3s ease-out;
      }

      @keyframes slideIn {
        from {
          transform: translateX(50px);
          opacity: 0;
        }

        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      .panel-header {
        padding: 20px;
        background: rgba(255, 255, 255, 0.03);
        border-bottom: 1px solid var(--glass-border);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .panel-header h3 {
        margin: 0;
        font-size: 1.1rem;
        color: var(--accent-primary);
      }

      .close-btn {
        cursor: pointer;
        color: var(--text-dim);
        padding: 4px;
      }

      .panel-content {
        padding: 20px;
        overflow-y: auto;
        flex: 1;
      }

      .form-group {
        margin-bottom: 20px;
      }

      .form-group label {
        display: block;
        font-size: 0.8rem;
        color: var(--text-dim);
        margin-bottom: 8px;
      }

      .form-group input,
      .form-group textarea {
        width: 100%;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid var(--glass-border);
        border-radius: 8px;
        padding: 10px;
        color: white;
        box-sizing: border-box;
        outline: none;
      }

      .form-group input:focus {
        border-color: var(--accent-primary);
      }

      /* Buttons */
      .btn {
        padding: 10px 16px;
        border-radius: 10px;
        border: none;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      .btn-primary {
        background: var(--accent-primary);
        color: var(--bg-color);
      }

      .btn-ghost {
        background: transparent;
        border: 1px solid var(--glass-border);
        color: var(--text-main);
      }

      .btn-danger {
        background: var(--danger);
        color: white;
      }

      .btn-full {
        width: 100%;
      }

      .btn:hover {
        opacity: 0.9;
        transform: translateY(-1px);
      }

      /* Switches */
      .switch-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .switch {
        position: relative;
        display: inline-block;
        width: 44px;
        height: 22px;
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        inset: 0;
        background-color: rgba(255, 255, 255, 0.1);
        transition: 0.3s;
        border-radius: 22px;
      }

      .slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.3s;
        border-radius: 50%;
      }

      input:checked + .slider {
        background-color: var(--accent-primary);
      }

      input:checked + .slider:before {
        transform: translateX(22px);
      }

      /* List Items */
      .list-item {
        background: rgba(255, 255, 255, 0.03);
        border-radius: 12px;
        padding: 12px;
        margin-bottom: 10px;
        border: 1px solid transparent;
        transition: all 0.2s;
      }

      .list-item:hover {
        border-color: var(--glass-border);
        background: rgba(255, 255, 255, 0.05);
      }

      /* Toast */
      #toast {
        position: fixed;
        top: 32px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--glass-bg);
        backdrop-filter: blur(12px);
        border: 1px solid var(--glass-border);
        padding: 12px 24px;
        border-radius: 12px;
        z-index: 1000;
        display: none;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        animation: fadeInOut 3s forwards;
      }

      @keyframes fadeInOut {
        0% {
          opacity: 0;
          transform: translate(-50%, -20px);
        }

        15% {
          opacity: 1;
          transform: translate(-50%, 0);
        }

        85% {
          opacity: 1;
          transform: translate(-50%, 0);
        }

        100% {
          opacity: 0;
          transform: translate(-50%, -20px);
        }
      }

      /* Responsive */
      @media (max-width: 768px) {
        .side-panel {
          width: calc(100% - 48px);
        }

        .dock {
          padding: 8px 16px;
          bottom: 20px;
          overflow-x: auto;
          max-width: 90%;
        }
      }

      /* Search Candidates */
      .search-results {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: var(--glass-bg);
        backdrop-filter: blur(12px);
        border: 1px solid var(--glass-border);
        border-radius: 12px;
        margin-top: 8px;
        max-height: 300px;
        overflow-y: auto;
        display: none;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      }

      .search-item {
        padding: 10px 12px;
        cursor: pointer;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .search-item:hover,
      .search-item.active {
        background: rgba(255, 255, 255, 0.1);
        color: var(--accent-primary);
      }

      /* Browser Panel */
      .browser-tabs {
        display: flex;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 12px;
        padding: 4px;
        margin-bottom: 15px;
      }

      .browser-tab {
        flex: 1;
        text-align: center;
        padding: 8px;
        cursor: pointer;
        border-radius: 8px;
        font-size: 0.9rem;
        color: var(--text-dim);
        transition: all 0.2s;
      }

      .browser-tab.active {
        background: var(--accent-primary);
        color: var(--bg-color);
        font-weight: 600;
      }

      .group-header {
        font-size: 0.8rem;
        font-weight: 600;
        color: var(--accent-secondary);
        margin: 15px 0 8px 0;
        padding-left: 8px;
        border-left: 2px solid var(--accent-secondary);
      }

      .group-content {
        display: grid;
        gap: 6px;
      }

      /* Help Content Styles */
      .help-section {
        margin-bottom: 24px;
      }
      .help-title {
        font-size: 1rem;
        color: var(--accent-primary);
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .help-item {
        display: flex;
        gap: 12px;
        margin-bottom: 12px;
        font-size: 0.85rem;
        line-height: 1.5;
      }
      .help-key {
        background: rgba(255, 255, 255, 0.1);
        padding: 2px 6px;
        border-radius: 4px;
        color: var(--accent-secondary);
        font-family: monospace;
        font-weight: 600;
        white-space: nowrap;
      }
      .help-desc {
        color: var(--text-dim);
      }
      .help-feature {
        background: rgba(56, 189, 248, 0.05);
        padding: 12px;
        border-radius: 12px;
        border: 1px border var(--glass-border);
      }

      /* Toggle Switch */
      .switch {
        position: relative;
        display: inline-block;
        width: 36px;
        height: 20px;
      }
      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .slider-round {
        position: absolute;
        cursor: pointer;
        inset: 0;
        background-color: rgba(255, 255, 255, 0.1);
        transition: 0.4s;
        border-radius: 20px;
      }
      .slider-round:before {
        position: absolute;
        content: "";
        height: 14px;
        width: 14px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
      }
      input:checked + .slider-round {
        background-color: var(--accent-primary);
      }
      input:checked + .slider-round:before {
        transform: translateX(16px);
      }
    </style>
  </head>

  <body>
    <!-- Initial Loader -->
    <div id="loader">
      <div class="spinner"></div>
      <p class="loader-text">æ­£åœ¨åŒæ­¥å…¨æ™¯çŸ¥è¯†å›¾è°±...</p>
      <p style="margin-top: 8px; color: var(--text-dim); font-size: 0.8rem; opacity: 0.8">
        åˆæ¬¡ä½¿ç”¨ï¼Ÿè¯·åœ¨åŠ è½½å®Œæˆåç‚¹å‡»æ“ä½œæŒ‡å—äº†è§£åŸºç¡€æ“ä½œ
      </p>
    </div>

    <!-- Graph Surface -->
    <div id="container"></div>

    <!-- Search Box -->
    <div class="search-container">
      <input
        type="text"
        id="node-search-input"
        placeholder="è¾“å…¥å…³é”®è¯ (æ”¯æŒæ‹¼éŸ³/ID)..."
        autocomplete="off"
        oninput="handleSearchInput(this.value)"
        onblur="setTimeout(() => hideSearchResults(), 200)"
      />
      <div id="search-results" class="search-results"></div>
    </div>

    <!-- Dock Menu -->
    <div class="dock">
      <div class="dock-btn" onclick="loadData()">
        <div class="dock-icon">ğŸ”„</div>
        <span>åŒæ­¥çŠ¶æ€</span>
      </div>
      <div class="dock-btn" onclick="layout()">
        <div class="dock-icon">ğŸ“</div>
        <span>é‡æ’å¸ƒå±€</span>
      </div>
      <div class="dock-btn" onclick="toggleSimulation()">
        <div class="dock-icon" id="sim-btn-icon">â¸ï¸</div>
        <span id="sim-btn-text">æš‚åœæ¨¡æ‹Ÿ</span>
      </div>
      <div class="dock-btn" onclick="openPanel('content-browser-panel')">
        <div class="dock-icon">ğŸ“–</div>
        <span>å†…å®¹å­—å…¸</span>
      </div>
      <div class="dock-btn" onclick="openPanel('recycle-bin-panel')">
        <div class="dock-icon">â™»ï¸</div>
        <span>å›æ”¶ç«™</span>
      </div>
      <div class="divider"></div>
      <div class="dock-btn" onclick="openPanel('add-node-panel')">
        <div class="dock-icon">â•</div>
        <span>æ–°å¢èŠ‚ç‚¹</span>
      </div>
      <div class="dock-btn" onclick="openPanel('source-manager-panel')">
        <div class="dock-icon">ğŸ“‚</div>
        <span>è®°å¿†æº¯æº</span>
      </div>
      <div class="dock-btn" onclick="openPanel('person-profile-panel')">
        <div class="dock-icon">ğŸ‘¤</div>
        <span>äººç‰©ç”»åƒ</span>
      </div>
      <div class="dock-btn" onclick="manualSave()">
        <div class="dock-icon">ğŸ’¾</div>
        <span>æŒä¹…åŒ–</span>
      </div>
      <div class="divider"></div>
      <div class="dock-btn" onclick="openPanel('view-settings-panel')">
        <div class="dock-icon">âš™ï¸</div>
        <span>è§†å›¾é…ç½®</span>
      </div>
      <div class="divider"></div>
      <div class="dock-btn" onclick="openPanel('help-panel')">
        <div class="dock-icon">â“</div>
        <span>æ“ä½œæŒ‡å—</span>
      </div>
    </div>

    <!-- Data Suggestions -->
    <datalist id="node-list-suggestions"></datalist>

    <!-- Generic Side Panel Wrapper -->
    <div id="side-panel" class="side-panel">
      <div class="panel-header">
        <h3 id="panel-title">å±æ€§ä¿¡æ¯</h3>
        <div class="close-btn" onclick="closePanel()">âœ•</div>
      </div>
      <div class="panel-content" id="panel-body">
        <!-- Content will be injected here -->
      </div>
    </div>

    <!-- Dynamic Containers (Templates for injection) -->
    <div id="templates" style="display: none">
      <!-- Node Panel -->
      <div id="node-editor-tpl">
        <div style="text-align: center; margin-bottom: 24px">
          <div style="font-size: 0.8rem; color: var(--text-dim)">
            å½“å‰é€‰ä¸­å®ä½“
          </div>
          <div
            style="
              font-size: 1.4rem;
              font-weight: 600;
              color: var(--accent-primary);
            "
            id="node-id-display"
          ></div>
        </div>

        <div class="form-group">
          <label>ä¿®æ”¹å®æ ‡</label>
          <input type="text" id="rename-input" placeholder="è¯·è¾“å…¥æ–°åç§°" />
        </div>

        <div style="display: flex; gap: 8px; margin-bottom: 24px">
          <button class="btn btn-primary btn-full" onclick="renameNode()">
            é‡å‘½å
          </button>
          <button
            class="btn btn-danger"
            onclick="deleteNode()"
            title="å½»åº•åˆ é™¤"
          >
            ğŸ—‘ï¸
          </button>
        </div>

        <div
          style="border-top: 1px solid var(--glass-border); padding-top: 20px"
        >
          <label style="font-size: 0.8rem; color: var(--text-dim)"
            >å¿«é€Ÿæ·»åŠ å…³è”</label
          >
          <div
            style="
              background: rgba(255, 255, 255, 0.03);
              padding: 12px;
              border-radius: 12px;
              margin-top: 8px;
            "
          >
            <input
              type="text"
              id="quick-target"
              placeholder="ç›®æ ‡å®ä½“"
              list="node-list-suggestions"
              style="
                margin-bottom: 8px;
                width: 100%;
                padding: 8px;
                background: rgba(0, 0, 0, 0.2);
                border: 1px solid var(--glass-border);
                border-radius: 6px;
                color: white;
              "
            />
            <input
              type="text"
              id="quick-predicate"
              placeholder="æè¿°å…³ç³» (å¦‚: å±…ä½äº)"
              style="
                margin-bottom: 12px;
                width: 100%;
                padding: 8px;
                background: rgba(0, 0, 0, 0.2);
                border: 1px solid var(--glass-border);
                border-radius: 6px;
                color: white;
              "
            />
            <button
              class="btn btn-primary btn-full"
              onclick="submitQuickRelation()"
            >
              ç¡®è®¤å»ºç«‹
            </button>
          </div>
        </div>

        <div id="relations-list-root" style="margin-top: 24px"></div>
        <div id="sources-list-root" style="margin-top: 24px"></div>
      </div>

      <!-- è¾¹é¢æ¿ (Edge Panel) -->
      <div id="edge-editor-tpl">
        <div style="text-align: center; margin-bottom: 24px">
          <div style="font-size: 0.8rem; color: var(--text-dim)">å…³ç³»è¯¦æƒ…</div>
          <div
            style="font-size: 1.1rem; color: var(--text-main)"
            id="edge-title-display"
          ></div>
        </div>
        <div class="form-group">
          <label
            >è¿æ¥å¼ºåº¦ (0.1 - 5.0):
            <span id="weight-val-display" style="float: right">1.0</span></label
          >
          <input
            type="range"
            id="weight-slider"
            min="0.1"
            max="5"
            step="0.1"
            value="1.0"
            oninput="
              document.getElementById('weight-val-display').innerText =
                this.value
            "
          />
        </div>
        <button
          class="btn btn-primary btn-full"
          onclick="saveEdge()"
          style="margin-bottom: 8px"
        >
          åŒæ­¥æƒé‡
        </button>
        <button class="btn btn-danger btn-full" onclick="deleteEdge()">
          åˆ‡æ–­æ­¤è¿æ¥
        </button>

        <div id="edge-sources-list-root" style="margin-top: 24px"></div>
        
        <!-- V5 è®°å¿†æ§åˆ¶ (V5 Memory Controls) -->
        <div style="border-top: 1px solid var(--glass-border); margin-top: 20px; padding-top: 15px;">
           <label style="font-size: 0.8rem; color: var(--text-dim); margin-bottom: 10px; display: block;">è®°å¿†å…¨ç”Ÿå‘½å‘¨æœŸç®¡ç†</label>
           <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">
               <button class="btn btn-ghost" onclick="reinforceEdge()" title="å¼ºåŒ–è®°å¿† (é‡ç½®è¡°é€€)">
                 ğŸ’ª å¼ºåŒ–
               </button>
               <button class="btn btn-ghost" onclick="protectEdge()" title="ä¿æŠ¤/ç½®é¡¶ (é˜²æ­¢é—å¿˜)">
                 ğŸ“Œ ä¿æŠ¤
               </button>
               <button class="btn btn-ghost" onclick="freezeEdge()" title="å†·å†» (è½¬ä¸ºéæ´»è·ƒ)">
                 â„ï¸ å†·å†»
               </button>
           </div>
        </div>

      <!-- æ–°å¢èŠ‚ç‚¹é¢æ¿ (Add Node Panel) -->
      <div id="add-node-tpl">
        <div class="form-group">
          <label>å®ä½“åç§°</label>
          <input
            type="text"
            id="new-node-name"
            placeholder="è¯·è¾“å…¥æ–°å®ä½“åç§°"
          />
        </div>
        <button class="btn btn-primary btn-full" onclick="addNode()">
          åˆ›å»ºå¹¶åŒæ­¥
        </button>
      </div>

      <!-- æ–°å¢å…³ç³»é¢æ¿ (Add Edge Panel) -->
      <div id="add-edge-tpl">
        <div class="form-group">
          <label>æºå®ä½“</label>
          <input
            type="text"
            id="edge-source"
            placeholder="èµ·å§‹ç‚¹"
            list="node-list-suggestions"
          />
        </div>
        <div class="form-group">
          <label>ç›®æ ‡å®ä½“</label>
          <input
            type="text"
            id="edge-target"
            placeholder="æŒ‡å‘ç‚¹"
            list="node-list-suggestions"
          />
        </div>
        <div class="form-group">
          <label>è°“è¯æè¿° (è¯å‘é‡æ„ŸçŸ¥)</label>
          <input
            type="text"
            id="edge-predicate"
            placeholder="ä¾‹å¦‚: å…³è”è‡ª, å±äº, å–œæ¬¢"
          />
        </div>
        <button class="btn btn-primary btn-full" onclick="addEdge()">
          å»ºç«‹é€»è¾‘æ˜ å°„
        </button>
      </div>

      <!-- æº¯æºç®¡ç†é¢æ¿ (Source Manager Panel) -->
      <div id="source-manager-tpl">
        <div class="switch-row">
          <span style="font-size: 0.85rem">è‡ªåŠ¨ä¿å­˜ (Runtime)</span>
          <label class="switch">
            <input
              type="checkbox"
              id="auto-save-toggle"
              onchange="toggleAutoSave(this.checked)"
            />
            <span class="slider"></span>
          </label>
        </div>
        <div
          style="margin-top: 10px; max-height: 400px; overflow-y: auto"
          id="source-files-list"
        >
          <!-- Records -->
        </div>
      </div>

      <!-- äººç‰©ç”»åƒé¢æ¿ (Person Profile Panel) -->
      <div id="person-profile-tpl">
        <div class="form-group">
          <label>äººç‰©ID / äººå / åˆ«å</label>
          <input
            type="text"
            id="person-profile-keyword"
            placeholder="ä¾‹å¦‚: person_id æˆ– å°æ˜"
          />
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 12px">
          <button class="btn btn-primary btn-full" onclick="queryPersonProfile()">
            æŸ¥è¯¢ç”»åƒ
          </button>
          <button class="btn btn-ghost" onclick="queryPersonProfile(true)">
            å¼ºåˆ¶åˆ·æ–°
          </button>
          <button class="btn btn-ghost" onclick="loadPersonProfileList(1)">
            äººç‰©åˆ—è¡¨
          </button>
        </div>
        <div
          id="person-profile-list-meta"
          style="font-size: 0.78rem; color: var(--text-dim); margin-bottom: 6px"
        >
          åˆ—è¡¨æœªåŠ è½½
        </div>
        <div
          id="person-profile-list-root"
          style="
            max-height: 180px;
            overflow-y: auto;
            margin-bottom: 10px;
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 6px;
          "
        >
          <div style="font-size: 0.8rem; color: var(--text-dim); text-align: center; padding: 8px">
            ç‚¹å‡»â€œäººç‰©åˆ—è¡¨â€åŠ è½½
          </div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 12px">
          <button class="btn btn-ghost btn-full" onclick="prevPersonProfilePage()">ä¸Šä¸€é¡µ</button>
          <button class="btn btn-ghost btn-full" onclick="nextPersonProfilePage()">ä¸‹ä¸€é¡µ</button>
        </div>
        <div
          id="person-profile-meta"
          style="font-size: 0.78rem; color: var(--text-dim); margin-bottom: 12px"
        >
          æœªæŸ¥è¯¢
        </div>
        <div class="form-group">
          <label>ç³»ç»Ÿç”»åƒï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰</label>
          <textarea
            id="person-profile-auto"
            rows="8"
            readonly
            placeholder="æŸ¥è¯¢åæ˜¾ç¤ºè‡ªåŠ¨ç”»åƒ"
          ></textarea>
        </div>
        <div class="form-group">
          <label>æ‰‹å·¥ä¿®è®¢ç”»åƒï¼ˆä¼˜å…ˆæ³¨å…¥ï¼‰</label>
          <textarea
            id="person-profile-override"
            rows="6"
            placeholder="å¯å¡«å†™äººå·¥ä¿®è®¢å†…å®¹ï¼›ä¿å­˜åå°†è¦†ç›–è‡ªåŠ¨æ³¨å…¥æ–‡æœ¬"
          ></textarea>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 12px">
          <button class="btn btn-primary btn-full" onclick="savePersonProfileOverride()">
            ä¿å­˜ä¿®è®¢
          </button>
          <button class="btn btn-danger" onclick="clearPersonProfileOverride()">
            æ¸…é™¤ä¿®è®¢
          </button>
        </div>
        <div class="form-group">
          <label>æœ€ç»ˆæ³¨å…¥ç”»åƒï¼ˆå½“å‰ç”Ÿæ•ˆï¼‰</label>
          <textarea
            id="person-profile-merged"
            rows="8"
            readonly
            placeholder="æŸ¥è¯¢åæ˜¾ç¤ºæœ€ç»ˆæ³¨å…¥æ–‡æœ¬"
          ></textarea>
        </div>
      </div>

      <!-- å†…å®¹æµè§ˆå™¨é¢æ¿ (Content Browser Panel) -->
      <div id="content-browser-tpl">
        <div class="browser-tabs">
          <div class="browser-tab active" onclick="switchBrowserTab('nodes')">
            å®ä½“åˆ—è¡¨
          </div>
          <div class="browser-tab" onclick="switchBrowserTab('edges')">
            å…³ç³»åˆ—è¡¨
          </div>
        </div>

        <input
          type="text"
          id="browser-filter"
          placeholder="ç­›é€‰åˆ—è¡¨..."
          style="
            width: 100%;
            margin-bottom: 12px;
            background: rgba(0, 0, 0, 0.2);
            padding: 8px;
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            color: white;
          "
          oninput="renderBrowserContent()"
        />

        <div
          id="browser-content-root"
          style="
            overflow-y: auto;
            height: calc(100vh - 250px);
            padding-right: 4px;
          "
        >
          <!-- Content -->
        </div>
      </div>

      <!-- å›æ”¶ç«™é¢æ¿ (Recycle Bin Panel) -->
      <div id="recycle-bin-tpl">
        <div style="text-align: center; margin-bottom: 24px">
           <div style="font-size: 0.8rem; color: var(--text-dim)">å›æ”¶ç«™</div>
           <div style="font-size: 1.1rem; color: var(--text-main)">å·²åˆ é™¤è®°å¿†</div>
        </div>
        
        <div style="margin-bottom: 12px; font-size: 0.85rem; color: var(--text-dim); text-align: center;">
           â„¹ï¸ ä»…ä¿ç•™æœ€è¿‘åˆ é™¤çš„50æ¡è®°å½•
        </div>

        <div id="recycle-list-root" style="overflow-y: auto; height: calc(100vh - 250px); padding-right: 4px;">
           <div style="text-align:center; padding:20px; color:var(--text-dim)">åŠ è½½ä¸­...</div>
        </div>
      </div>

      <!-- å¸®åŠ©é¢æ¿ (Help Panel) -->
      <div id="help-tpl">
        <div class="help-section">
          <div class="help-title"><span>ğŸ–±ï¸</span> åŸºç¡€äº¤äº’</div>
          <div class="help-item">
            <span class="help-key">æ‹–æ‹½</span>
            <span class="help-desc">ç§»åŠ¨å›¾è°±ç”»å¸ƒ</span>
          </div>
          <div class="help-item">
            <span class="help-key">ä¸­é”®/æ»šè½®</span>
            <span class="help-desc">ç¼©æ”¾è§†è§’å¤§å°</span>
          </div>
          <div class="help-item">
            <span class="help-key">ç‚¹å‡»</span>
            <span class="help-desc">é€‰ä¸­èŠ‚ç‚¹æˆ–è¿çº¿æŸ¥çœ‹è¯¦ç»†å±æ€§åŠæ¥æº</span>
          </div>
        </div>

        <div class="help-section help-feature">
          <div class="help-title"><span>ğŸ§ </span> æ™ºèƒ½æ˜¾è‘—æ€§è§†å›¾</div>
          <p class="help-desc" style="font-size: 0.8rem; margin: 0 0 10px 0">
            ç³»ç»ŸåŸºäº<b>PageRankæ‹“æ‰‘é‡è¦æ€§</b>æ™ºèƒ½ç­›é€‰æ˜¾ç¤ºå†…å®¹ã€‚
          </p>
          <div class="help-item">
            <span class="help-key">å¯†åº¦æ»‘å—</span>
            <span class="help-desc">å‘å·¦èšç„¦æ ¸å¿ƒéª¨å¹²ï¼Œå‘å³å±•å¼€å…¨é‡ç»†èŠ‚ã€‚</span>
          </div>
          <div class="help-item">
            <span class="help-key">å¹½çµèŠ‚ç‚¹</span>
            <span class="help-desc">åŠé€æ˜èƒŒæ™¯èŠ‚ç‚¹ä»£è¡¨æ¬¡è¦å…³è”ï¼Œæä¾›æ¢ç´¢çº¿ç´¢ã€‚</span>
          </div>
        </div>

        <div class="help-section" style="margin-top: 24px">
          <div class="help-title"><span>ğŸ› ï¸</span> å…¨åŠŸèƒ½å¯¼èˆª</div>
          
          <div style="font-size:0.85rem; font-weight:600; color:var(--text-main); margin-bottom:8px;">åº•éƒ¨ Dock æ </div>
          <div class="help-item">
            <span class="help-key">ğŸ”„ åŒæ­¥çŠ¶æ€</span>
            <span class="help-desc">æ‰‹åŠ¨åˆ·æ–°å›¾è°±ï¼Œè·å–æœ€æ–°æ•°æ®ï¼ˆå«åŠ è½½åŠ¨ç”»ï¼‰ã€‚</span>
          </div>
          <div class="help-item">
            <span class="help-key">ğŸ“ é‡æ’å¸ƒå±€</span>
            <span class="help-desc">è§¦å‘ç‰©ç†å¼•æ“é‡æ–°è®¡ç®—èŠ‚ç‚¹ä½ç½®ã€‚</span>
          </div>
          <div class="help-item">
            <span class="help-key">â¯ï¸ æ¨¡æ‹Ÿæ§åˆ¶</span>
            <span class="help-desc">æš‚åœ/ç»§ç»­ç‰©ç†æ¨¡æ‹Ÿï¼Œå¤§å‹å›¾è°±æ¨èæš‚åœä»¥èŠ‚çœæ€§èƒ½ã€‚</span>
          </div>
          <div class="help-item">
            <span class="help-key">ğŸ“– å†…å®¹å­—å…¸</span>
            <span class="help-desc">åˆ—è¡¨åŒ–æŸ¥çœ‹æ‰€æœ‰å®ä½“å’Œå…³ç³»ï¼Œæ”¯æŒå…³é”®è¯æ£€ç´¢ã€‚</span>
          </div>
          
          <div class="divider" style="height:1px; width:100%; margin:12px 0;"></div>
          
          <div style="font-size:0.85rem; font-weight:600; color:var(--text-main); margin-bottom:8px;">ç¼–è¾‘ä¸ç®¡ç†</div>
          <div class="help-item">
            <span class="help-key">â•/ğŸ”— æ–°å¢</span>
            <span class="help-desc">æ‰‹åŠ¨åˆ›å»ºçŸ¥è¯†å®ä½“æˆ–å»ºç«‹ä¸¤ç‚¹é—´çš„è¯­ä¹‰å…³è”ã€‚</span>
          </div>
          <div class="help-item">
            <span class="help-key">ğŸ“‚ è®°å¿†æº¯æº</span>
            <span class="help-desc">ç®¡ç†å¯¼å…¥çš„æºæ–‡ä»¶æ‰¹æ¬¡ï¼Œæ”¯æŒæ‰¹é‡èšç„¦æˆ–åˆ é™¤è®°å¿†ã€‚</span>
          </div>
          <div class="help-item">
            <span class="help-key">ğŸ’¾ æŒä¹…åŒ–</span>
            <span class="help-desc">å¼ºåˆ¶å°†å†…å­˜æ•°æ®å†™å…¥ç£ç›˜ï¼ˆé€šå¸¸ç³»ç»Ÿä¼šè‡ªåŠ¨ä¿å­˜ï¼‰ã€‚</span>
          </div>
          
           <div class="divider" style="height:1px; width:100%; margin:12px 0;"></div>

          <div style="font-size:0.85rem; font-weight:600; color:var(--text-main); margin-bottom:8px;">âš™ï¸ è§†å›¾é…ç½®</div>
          <div class="help-item">
            <span class="help-key">è¯¦ç»†æ¨¡å¼</span>
            <span class="help-desc">å¼€å¯å…¨é‡æ˜¾ç¤ºï¼ˆå¿½ç•¥å¯†åº¦ç­›é€‰ï¼‰ï¼Œé€‚åˆå°è§„æ¨¡å›¾è°±ã€‚</span>
          </div>
          <div class="help-item">
            <span class="help-key">èŠ‚èƒ½æ¨¡å¼</span>
            <span class="help-desc">ç®€åŒ–æ¸²æŸ“ï¼ˆæ— é˜´å½±ã€ç›´çº¿è¿æ¥ï¼‰ï¼Œæå‡å¤§å›¾æµç•…åº¦ã€‚</span>
          </div>
        </div>

        <p style="text-align: center; color: var(--accent-secondary); font-size: 0.75rem; border-top: 1px solid var(--glass-border); padding-top: 16px;">
          A_Memorix Panorama View v1.3
        </p>
      </div>

      <!-- è§†å›¾è®¾ç½®é¢æ¿ (View Settings Panel) -->
      <div id="view-settings-tpl">
        <div class="group-header">è§†è§‰å¤–è§‚</div>
        <div class="group-content">
          <button
            class="btn btn-ghost"
            onclick="toggleTheme()"
            style="justify-content: flex-start"
          >
            <span>ğŸ¨ åˆ‡æ¢é…è‰²ä¸»é¢˜</span>
          </button>
          <div
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
              padding: 10px;
              background: rgba(255, 255, 255, 0.03);
              border-radius: 8px;
            "
          >
            <span style="font-size: 0.85rem; color: var(--text-dim)"
              >âš¡ èŠ‚èƒ½æ¨¡å¼</span
            >
            <label class="switch">
              <input
                type="checkbox"
                id="settings-perf-mode"
                onchange="toggleLowPerfMode()"
              />
              <span class="slider-round"></span>
            </label>
          </div>
        </div>

        <div class="group-header">ä¿¡æ¯æ˜¾åº¦æ§åˆ¶</div>
        <div
          class="group-content"
          style="
            padding: 10px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
          "
        >
          <div
            style="
              display: flex;
              justify-content: space-between;
              margin-bottom: 15px;
            "
          >
            <span style="font-size: 0.85rem; color: var(--text-dim)"
              >è¯¦ç»†æ¨¡å¼</span
            >
            <label class="switch">
              <input
                type="checkbox"
                id="settings-detailed-mode"
                onchange="toggleDetailedMode()"
              />
              <span class="slider-round"></span>
            </label>
          </div>

          <div
            id="density-control-area"
            style="opacity: 0.5; pointer-events: none"
          >
            <label
              style="
                font-size: 0.75rem;
                color: var(--accent-primary);
                display: block;
                margin-bottom: 8px;
              "
              >æ˜¾è‘—æ€§å¯†åº¦: <span id="density-val">50</span>%</label
            >
            <input
              type="range"
              id="density-slider"
              min="0"
              max="1"
              step="0.05"
              value="0.5"
              style="width: 100%"
              oninput="updateDensity(this.value)"
            />
            <div
              style="
                display: flex;
                justify-content: space-between;
                font-size: 0.65rem;
                color: var(--text-dim);
                margin-top: 5px;
              "
            >
              <span>æ ¸å¿ƒéª¨å¹²</span>
              <span>å¹³è¡¡</span>
              <span>å…¨é‡æœ«æ¢¢</span>
            </div>
          </div>
        </div>

        <div class="group-header">å¿«æ·æ“ä½œ</div>
        <div class="group-content">
          <button
            class="btn btn-ghost"
            onclick="openPanel('add-node-panel')"
            style="justify-content: flex-start"
          >
            <span>â• æ–°å¢çŸ¥è¯†å®ä½“</span>
          </button>
          <button
            class="btn btn-ghost"
            onclick="openPanel('add-edge-panel')"
            style="justify-content: flex-start"
          >
            <span>ğŸ”— å»ºç«‹è¯­ä¹‰å…³ç³»</span>
          </button>
          <button
            class="btn btn-ghost"
            onclick="manualSave()"
            style="justify-content: flex-start"
          >
            <span>ğŸ’¾ æ‰§è¡Œæ•°æ®æŒä¹…åŒ–</span>
          </button>
        </div>
      </div>
    </div>

    <div id="toast">æ“ä½œæˆåŠŸ</div>

    <script>
      let network = null;
      let nodes = new vis.DataSet([]);
      let edges = new vis.DataSet([]);
      let currentSelection = null;
      let detailedMode = false; // By default, exclude leaves
      let currentSource = null; // Current batch filter
      let isHighlighting = false; // Focus fade state
      let isLowPerfMode = false; // Low Performance Mode
      let infoDensity = 0.5; // Shared state for saliency filtering
      let isSimulationRunning = true; // Physics simulation state
      let _freezeTimer = null;

      // åŠ è½½æ§åˆ¶ (Loading Control)
      function showLoader(text = "æ­£åœ¨åŒæ­¥å…¨æ™¯çŸ¥è¯†å›¾è°±...", isSync = false) {
        const loader = document.getElementById("loader");
        const textEl = loader.querySelector(".loader-text");
        if (textEl) textEl.innerText = text;
        
        if (isSync) {
          loader.classList.add("sync-mode");
        } else {
          loader.classList.remove("sync-mode");
        }
        
        loader.style.display = "flex";
        // Force reflow
        loader.offsetHeight;
        loader.style.opacity = "1";
      }

      function hideLoader() {
        const loader = document.getElementById("loader");
        loader.style.opacity = "0";
        setTimeout(() => {
          loader.style.display = "none";
        }, 500);
      }

      // ä¸»é¢˜é…ç½® (Theme Config)
      const THEMES = ["dark", "light", "neon"];
      let currentThemeIdx = 0;
      const THEME_CONFIG = {
        dark: {
          background: "#0f172a",
          node: { background: "#38bdf8", border: "#0ea5e9", font: "#f1f5f9" },
          edge: { color: "rgba(148, 163, 184, 0.4)", highlight: "#38bdf8" },
          v5: {
             inactive: "rgba(203, 213, 225, 0.4)", // Slate-300
             pinned: "rgba(251, 191, 36, 0.8)",    // Amber-400
             protected: "rgba(52, 211, 153, 0.8)"  // Emerald-400
          }
        },
        light: {
          background: "#f8fafc",
          node: { background: "#0284c7", border: "#0369a1", font: "#1e293b" },
          edge: { color: "rgba(100, 116, 139, 0.4)", highlight: "#0284c7" },
          v5: {
             inactive: "rgba(148, 163, 184, 0.4)", // Slate-400
             pinned: "rgba(245, 158, 11, 0.8)",    // Amber-500
             protected: "rgba(16, 185, 129, 0.8)"  // Emerald-500
          }
        },
        neon: {
          background: "#13001f",
          node: { background: "#d946ef", border: "#c026d3", font: "#e9d5ff" },
          edge: { color: "rgba(217, 70, 239, 0.4)", highlight: "#d946ef" },
          v5: {
             inactive: "rgba(255, 255, 255, 0.2)",
             pinned: "rgba(252, 211, 77, 0.9)",
             protected: "rgba(110, 231, 183, 0.9)"
          }
        },
      };

      function toggleTheme() {
        currentThemeIdx = (currentThemeIdx + 1) % THEMES.length;
        const theme = THEMES[currentThemeIdx];
        document.documentElement.setAttribute("data-theme", theme);

        // å¦‚æœç½‘ç»œå·²å­˜åœ¨ï¼Œåˆ™é‡æ–°åº”ç”¨é€‰é¡¹
        if (network) applyThemeToNetwork(theme);
        showToast(`å·²åˆ‡æ¢ä¸»é¢˜: ${theme}`);
      }

      function toggleLowPerfMode() {
        setLowPerfMode(!isLowPerfMode);
      }

      function setLowPerfMode(enable) {
        isLowPerfMode = enable;

        if (isLowPerfMode) {
          if (network) {
            network.setOptions({
              nodes: { shadow: { enabled: false } },
              edges: { smooth: { enabled: false } }, // Straight lines
            });
          }
        } else {
          // Restore defaults
          if (network) {
            network.setOptions({
              nodes: {
                shadow: { enabled: true, color: "rgba(0,0,0,0.5)", size: 10 },
              },
              edges: {
                smooth: { type: "continuous", roundness: 0.5, enabled: true },
              },
            });
          }
        }
        updateSettingsUI();
      }

      function applyThemeToNetwork(theme) {
        const cfg = THEME_CONFIG[theme];
        document.body.style.backgroundColor = cfg.background; // ç¡®ä¿ body èƒŒæ™¯è‰²åŒ¹é…

        network.setOptions({
          nodes: {
            font: { color: cfg.node.font },
            color: {
              background: cfg.node.background,
              border: cfg.node.border,
              highlight: {
                background: cfg.node.background,
                border: cfg.node.border,
              },
            },
          },
          edges: {
            color: { color: cfg.edge.color, highlight: cfg.edge.highlight },
            font: { color: cfg.edge.color }, // Also update edge label default
          },
        });

        // å¦‚æœå½“å‰æ²¡æœ‰å¤„äºé«˜äº®çŠ¶æ€ï¼Œæˆ‘ä»¬åº”è¯¥å¼ºåˆ¶æ›´æ–°æ•°æ®é›†é¢œè‰²ä¸ºæ–°çš„é»˜è®¤å€¼
        if (!isHighlighting) {
          const allNodes = nodes.get();
          const updates = allNodes.map((n) => ({
            id: n.id,
            color: { background: cfg.node.background, border: cfg.node.border },
            font: { color: cfg.node.font },
          }));
          nodes.update(updates);

          const allEdges = edges.get();
          const edgeUpdates = allEdges.map((e) => {
            // åº”ç”¨ V5 é€»è¾‘ (Apply V5 Logic)
            let color = cfg.edge.color;
            let dashes = false;
            let shadow = false;
            let width = 1;
            
            if (e.is_active === false) { // Explicitly False (backend sends is_active=False)
                 color = cfg.v5.inactive;
                 dashes = true;
            } else if (e.is_pinned || e.is_protected) {
                 width = 2;
                 const shadowColor = e.is_pinned ? cfg.v5.pinned : cfg.v5.protected;
                 shadow = { enabled: true, color: shadowColor, size: 5 };
            }
            
            return {
                id: e.id,
                color: { color: color, highlight: cfg.edge.highlight },
                font: { color: cfg.edge.color },
                dashes: dashes,
                width: width,
                shadow: shadow
            };
          });
          edges.update(edgeUpdates);
        } else {
          // If highlighting, just reset to apply new base colors
          resetHighlight();
        }
      }

      // Init
      document.addEventListener("DOMContentLoaded", () => {
        initNetwork();
        loadData();
        loadConfig();
      });

      function initNetwork() {
        const container = document.getElementById("container");
        const data = { nodes: nodes, edges: edges };

        // Initial Theme: Dark
        const cfg = THEME_CONFIG["dark"];

        const options = {
          nodes: {
            shape: "dot",
            scaling: {
              min: 10,
              max: 40,
              label: { enabled: true, min: 14, max: 24 },
            },
            font: { color: cfg.node.font, face: "Outfit", strokeWidth: 0 },
            color: {
              background: cfg.node.background,
              border: cfg.node.border,
              highlight: {
                background: cfg.node.background,
                border: cfg.node.border,
              },
            },
            shadow: { enabled: true, color: "rgba(0,0,0,0.5)", size: 10 },
          },
          edges: {
            arrows: { to: { enabled: true, scaleFactor: 0.6 } },
            smooth: { type: "continuous", roundness: 0.5 },
            color: { color: cfg.edge.color, highlight: cfg.edge.highlight },
            font: {
              size: 11,
              color: "#94a3b8",
              strokeWidth: 0,
              align: "top",
              background: "transparent",
            },
            width: 1,
          },
          physics: {
            solver: "forceAtlas2Based",
            forceAtlas2Based: {
              gravitationalConstant: -120,
              centralGravity: 0.01,
              springLength: 120,
              springConstant: 0.08,
              damping: 0.4,
              avoidOverlap: 1,
            },
            stabilization: { iterations: 200 },
          },
          interaction: {
            hover: true,
            multiselect: false,
            tooltipDelay: 300,
          },
          layout: {
            improvedLayout: false, // æ€§èƒ½ä¼˜åŒ–ï¼šç¦ç”¨é»˜è®¤å¸ƒå±€ç®—æ³•ï¼Œä½¿ç”¨éšæœºæ•£ç‚¹
            randomSeed: 42 // ç¡®å®šæ€§å›é€€æ–¹æ¡ˆ (Deterministic fallback)
          }
        };

        network = new vis.Network(container, data, options);

        network.on("click", (params) => {
          if (params.nodes.length > 0) {
            onNodeClick(params.nodes[0]);
          } else if (params.edges.length > 0) {
            onEdgeClick(params.edges[0]);
          } else {
            resetHighlight();
            closePanel();
          }
        });

        // ç§»é™¤äº†è¿‡æ—©çš„ hideLoaderã€‚
        // åŠ è½½æ§åˆ¶ç°åœ¨å®Œå…¨ç”± loadData() ç®¡ç†ï¼Œä»¥ç¡®ä¿ç­‰å¾… API å“åº”ã€‚

        // LOD Events
        network.on("hoverNode", function (params) {
          if (isHighlighting || isZoomedIn()) return; // In focus mode or zoomed in, labels are fixed
          const ids = [params.node, ...network.getConnectedNodes(params.node)];
          const updates = [];
          ids.forEach((id) => {
            const node = nodes.get(id);
            // Show label if it's currently hidden
            if (node && (!node.label || !node.label.trim())) {
              updates.push({ id: id, label: node.hiddenLabel });
            }
          });
          if (updates.length > 0) nodes.update(updates);
        });

        network.on("blurNode", function (params) {
          if (isHighlighting || isZoomedIn()) return;
          const ids = [params.node, ...network.getConnectedNodes(params.node)];
          const updates = [];
          ids.forEach((id) => {
            const node = nodes.get(id);
            // Hide label if it's not a Hub
            if (node && !node.isHub && node.label === node.hiddenLabel) {
              updates.push({ id: id, label: " " });
            }
          });
          if (updates.length > 0) nodes.update(updates);
        });

        // Semantic Zoom (LOD) & Panning Update
        let viewUpdateThrottle = null;
        const throttledUpdate = () => {
          if (viewUpdateThrottle) return;
          viewUpdateThrottle = setTimeout(() => {
            updateLabelsByZoom();
            viewUpdateThrottle = null;
          }, 100);
        };

        network.on("zoom", throttledUpdate);
        network.on("drag", throttledUpdate);
        network.on("dragEnd", throttledUpdate);

        // Reliable Reset on Deselect
        network.on("deselectNode", () => {
          resetHighlight();
          closePanel();
        });
        network.on("deselectEdge", () => {
          resetHighlight();
          closePanel();
        });
      }

      function isZoomedIn() {
        return network && network.getScale() > 0.8;
      }

      function updateLabelsByZoom() {
        if (isHighlighting) return; // ä¸è¦å¹²æ‰°èšç„¦æ¨¡å¼

        const scale = network.getScale();
        const zoomedIn = scale > 0.8;
        const allNodes = nodes.get();
        const updates = [];

        // ä¼˜åŒ–ï¼šä»…åœ¨ç¼©æ”¾è¶³å¤Ÿå¤§æ—¶æ£€æŸ¥å¯è§æ€§
        const viewRect = zoomedIn
          ? network.canvas.frame.getBoundingClientRect()
          : null;

        allNodes.forEach((n) => {
          let shouldShow = n.isHub;

          if (zoomedIn) {
            // Check if node is in viewport
            const pos = network.getPositions([n.id])[n.id];
            if (pos) {
              const domPos = network.canvasToDOM(pos);
              if (
                domPos.x >= 0 &&
                domPos.x <= viewRect.width &&
                domPos.y >= 0 &&
                domPos.y <= viewRect.height
              ) {
                shouldShow = true;
              }
            }
          }

          const currentLabel = n.label;
          const targetLabel = shouldShow ? n.hiddenLabel : " ";

          if (currentLabel !== targetLabel) {
            updates.push({ id: n.id, label: targetLabel });
          }
        });

        if (updates.length > 0) nodes.update(updates);
      }

      async function loadData() {
        isHighlighting = false; // Reset highlight state
        showLoader("æ­£åœ¨åŒæ­¥å›¾è°±...", true);
        try {
          let url = `/api/graph?exclude_leaf=${!detailedMode}&density=${infoDensity}`;
          if (currentSource) {
            url += `&source=${encodeURIComponent(currentSource)}`;
          }
          const res = await axios.get(url);
          // æ•°æ®å·²è·å–ï¼Œæ­£åœ¨å¤„ç†å¹¶æ¸²æŸ“
          showLoader("æ­£åœ¨è§£ææ‹“æ‰‘ç»“æ„...", true);
          const data = res.data;

          // --- è‡ªé€‚åº”æ€§èƒ½é€»è¾‘ (Adaptive Performance Logic) ---
          const nodeCount = data.nodes.length;
          const edgeCount = data.edges.length;
          // å¯å‘å¼å¤æ‚åº¦ï¼šè¾¹çš„æˆæœ¬æ¯”èŠ‚ç‚¹ä½ï¼Œä½†å¯¹ç‰©ç†å¼•æ“å¾ˆé‡è¦
          const complexity = nodeCount + edgeCount * 0.2;

          applyAdaptiveSettings(complexity, nodeCount);

          // 1. Calculate degrees for LOD
          const degrees = {};
          data.edges.forEach((e) => {
            degrees[e.from] = (degrees[e.from] || 0) + 1;
            degrees[e.to] = (degrees[e.to] || 0) + 1;
          });

          // 2. Process Nodes with LOD logic
          let processedNodeIndex = 0; // For spiral layout
          const processedNodes = data.nodes.map((n) => {
            const deg = degrees[n.id] || 0;
            const isHub = deg > 5;
            const realLabel = n.label || n.id;

            // å¦‚æœæ ‡è®°äº†å¹½çµåŒ– (ghost)ï¼Œåˆ™åº”ç”¨å¹½çµæ ·å¼ (Ghosting Style)
            const opacity = n.is_ghost ? 0.2 : 1.0;

            // Use theme font color as base
            const themeCfg = THEME_CONFIG[THEMES[currentThemeIdx]];
            const fontColor = n.is_ghost
              ? hexToRgba(themeCfg.node.font, 0.4)
              : themeCfg.node.font;

            // Check if node exists to preserve position
            const exists = nodes.get(n.id);
            const baseNode = {
              ...n,
              value: 1,
              isHub: isHub,
              hiddenLabel: realLabel,
              label: isHub ? realLabel : " ",
              opacity: opacity,
              font: { color: fontColor },
            };

            // å¦‚æœæ˜¯æ–°èŠ‚ç‚¹ï¼Œä½¿ç”¨èºæ—‹å¸ƒå±€ (Spiral Layout) åˆ†é…ä½ç½®
            // èºæ—‹å¸ƒå±€å¯é¿å…é‡å ï¼Œå¹¶éšèŠ‚ç‚¹æ•°é‡æ‰©å±•
            if (!exists) {
                const nodeIndex = processedNodeIndex++;
                // èºæ—‹å¸ƒå±€å…¬å¼: r = a + b*theta, (x,y) = (r*cos(theta), r*sin(theta))
                const spacing = 80; // èºæ—‹è‡‚ä¹‹é—´çš„åŸºç¡€é—´è·
                const theta = nodeIndex * 0.5; // è§’åº¦å¢é‡
                const r = spacing * Math.sqrt(nodeIndex); // æ‰©å±•åŠå¾„
                baseNode.x = r * Math.cos(theta);
                baseNode.y = r * Math.sin(theta);
            }

            return baseNode;
          });

          // --- å¢é‡æ›´æ–°é€»è¾‘ï¼Œé˜²æ­¢å…¨å›¾è·³åŠ¨ ---

          // A. æ›´æ–°èŠ‚ç‚¹
          const newNodeIds = new Set(processedNodes.map((n) => n.id));
          const currentNodeIds = nodes.getIds();
          const nodesToRemove = currentNodeIds.filter(
            (id) => !newNodeIds.has(id),
          );

          if (nodesToRemove.length > 0) nodes.remove(nodesToRemove);
          nodes.update(processedNodes);

          // B. æ›´æ–°è¾¹
          // æ³¨æ„ï¼šVis.js è¾¹å¦‚æœæ²¡æœ‰ IDï¼Œæˆ‘ä»¬ä¼šæ ¹æ® from+to ç”Ÿæˆä¸€ä¸ªï¼Œä½† API è¿”å›çš„è¾¹é€šå¸¸æœ‰ ID æˆ–è€…æˆ‘ä»¬å¯ä»¥ç¨³å®šç”Ÿæˆ
          // ç¡®ä¿ API è¿”å›çš„è¾¹åŒ…å«ç¨³å®š ID
          const newEdgeIds = new Set(data.edges.map((e) => e.id));
          const currentEdgeIds = edges.getIds();
          const edgesToRemove = currentEdgeIds.filter(
            (id) => !newEdgeIds.has(id),
          );

          if (edgesToRemove.length > 0) edges.remove(edgesToRemove);
          edges.update(data.edges);

          // æ›´æ–°å»ºè®®åˆ—è¡¨ (Update datalist)
          const datalist = document.getElementById("node-list-suggestions");
          datalist.innerHTML = data.nodes
            .map((n) => `<option value="${n.id}">`)
            .join("");

          // ç»Ÿä¸€éšè— Loading
          if (processedNodes.length === 0) {
            hideLoader();
          } else if (network) {
            // ç­‰å¾…ä¸‹ä¸€æ¬¡ç»˜åˆ¶ä»¥ç¡®ä¿æ— é—ªçƒ (Wait for next draw to ensure no flickering)
            network.once("afterDrawing", () => hideLoader());
            // é˜²æ­¢ afterDrawing æœªè§¦å‘æˆ–å›¾è°±è¿‡äºç¨³å®šçš„å›é€€æ–¹æ¡ˆ
            setTimeout(() => hideLoader(), 2000);
          }

          // å¯¹äºå¤§è§„æ¨¡å›¾è°±ï¼Œè‡ªåŠ¨ç¼©å°è§†è§’ä»¥é˜²æ­¢ç‰¹å†™å¯¼è‡´çš„æ€§èƒ½å¡é¡¿
          if (complexity > 600 && network) {
            setTimeout(() => {
              // æ ¹æ®èŠ‚ç‚¹æ•°é‡è®¡ç®—åˆé€‚çš„ç¼©æ”¾æ¯”ä¾‹
              // èŠ‚ç‚¹è¶Šå¤šï¼Œç¼©æ”¾è¶Šå°
              const targetScale = Math.max(0.1, 0.5 / Math.log10(nodeCount));
              network.moveTo({
                scale: targetScale,
                animation: { duration: 300, easingFunction: "easeInOutQuad" }
              });
            }, 200);
          }
        } catch (err) {
          showToast("è¿æ¥å¤±è´¥: " + err.message);
          hideLoader();
        }
      }

      async function loadConfig() {
        try {
          const res = await axios.get("/api/config");
          // We'll update state when manager panel opens
        } catch (err) {}
      }

      function toggleDetailedMode() {
        detailedMode = !detailedMode;
        updateSettingsUI();
        loadData();
      }

      function updateDensity(val) {
        infoDensity = parseFloat(val);
        document.getElementById("density-val").innerText = Math.round(
          infoDensity * 100,
        );

        // Throttle reload
        if (window._densityTimeout) clearTimeout(window._densityTimeout);
        window._densityTimeout = setTimeout(() => {
          loadData();
        }, 300);
      }

      function updateSettingsUI() {
        const detailedCheckbox = document.getElementById(
          "settings-detailed-mode",
        );
        const perfCheckbox = document.getElementById("settings-perf-mode");
        const densityControl = document.getElementById("density-control-area");

        if (detailedCheckbox) detailedCheckbox.checked = detailedMode;
        if (perfCheckbox) perfCheckbox.checked = isLowPerfMode;

        if (densityControl) {
          // ä¿¡æ¯å¯†åº¦ä»…åœ¨éè¯¦ç»†ï¼ˆç®€åŒ–ï¼‰æ¨¡å¼ä¸‹ç›¸å…³ (Info Density only relevant in non-detailed mode)
          if (detailedMode) {
            densityControl.style.opacity = "0.3";
            densityControl.style.pointerEvents = "none";
          } else {
            densityControl.style.opacity = "1";
            densityControl.style.pointerEvents = "auto";
          }
        }
      }

      function layout() {
        if (network) network.stabilize();
      }

      // --- Panel Control ---

      function openPanel(type, data) {
        const panel = document.getElementById("side-panel");
        const title = document.getElementById("panel-title");
        const body = document.getElementById("panel-body");

        panel.style.display = "flex";

        if (type === "node-editor") {
          title.innerText = "å®ä½“å±æ€§";
          body.innerHTML = document.getElementById("node-editor-tpl").innerHTML;

          // Display Label, use ID for logic
          const nodeObj = nodes.get(data);
          document.getElementById("node-id-display").innerText = nodeObj
            ? nodeObj.label
            : data;

          renderNodeRelations(data);
          fetchSources({ node_id: data }, "sources-list-root");
          // è§¦å‘é«˜äº®æç¤º (Trigger Highlight)
          highlightNeighborhood(data);
        } else if (type === "edge-editor") {
          title.innerText = "å…³ç³»å±æ€§";
          body.innerHTML = document.getElementById("edge-editor-tpl").innerHTML;
          window.viewedEdgeId = data.id; // Correctly track viewed edge ID for actions
          
          // Display Source -> Target
          // And Relation Name below it
          const relationName = data.label || (data.predicates ? data.predicates.join(", ") : "å…³è”");
          
          document.getElementById("edge-title-display").innerHTML =
            `<div style="font-weight: bold;">${data.from} <span style="color: var(--text-dim)">â”</span> ${data.to}</div>
             <div style="font-size: 0.9rem; color: var(--accent-primary); margin-top: 4px;">${relationName}</div>`;
          document.getElementById("weight-slider").value = data.value || 1.0;
          document.getElementById("weight-val-display").innerText = (
            data.value || 1.0
          ).toFixed(1);
          fetchSources(
            { edge_source: data.from, edge_target: data.to },
            "edge-sources-list-root",
          );
        } else if (type === "add-node-panel") {
          title.innerText = "æ–°å¢å®ä½“";
          body.innerHTML = document.getElementById("add-node-tpl").innerHTML;
        } else if (type === "add-edge-panel") {
          title.innerText = "å»ºç«‹æ–°å…³ç³»";
          body.innerHTML = document.getElementById("add-edge-tpl").innerHTML;
        } else if (type === "recycle-bin-panel") {
          const tpl = document.getElementById("recycle-bin-tpl");
          title.innerText = "è®°å¿†å›æ”¶ç«™";
          body.innerHTML = tpl ? tpl.innerHTML : "Error: Template missing";
          loadRecycleBin();
        } else if (type === "source-manager-panel") {
          title.innerText = "è®°å¿†æº¯æºç®¡ç†";
          body.innerHTML =
            document.getElementById("source-manager-tpl").innerHTML;
          loadSourceFiles();
          // Check auto-save state
          axios.get("/api/config").then((res) => {
            document.getElementById("auto-save-toggle").checked =
              res.data.auto_save_enabled;
          });
        } else if (type === "person-profile-panel") {
          title.innerText = "äººç‰©ç”»åƒç®¡ç†";
          body.innerHTML =
            document.getElementById("person-profile-tpl").innerHTML;
          window.currentPersonProfile = null;
          window.personProfileListState = {
            page: 1,
            pageSize: 20,
            total: 0,
            keyword: "",
          };
          loadPersonProfileList(1);
        } else if (type === "content-browser-panel") {
          title.innerText = "çŸ¥è¯†å­—å…¸";
          body.innerHTML = document.getElementById(
            "content-browser-tpl",
          ).innerHTML;
          // Init browser
          window.currentBrowserTab = "nodes";
          renderBrowserContent();
        } else if (type === "view-settings-panel") {
          title.innerText = "è§†å›¾ç­–ç•¥é…ç½®";
          body.innerHTML =
            document.getElementById("view-settings-tpl").innerHTML;
          updateSettingsUI();
          // Set initial slider value
          document.getElementById("density-slider").value = infoDensity;
          document.getElementById("density-val").innerText = Math.round(
            infoDensity * 100,
          );
        } else if (type === "help-panel") {
          title.innerText = "æ“ä½œæŒ‡å—";
          body.innerHTML = document.getElementById("help-tpl").innerHTML;
        }
      }

      function closePanel() {
        document.getElementById("side-panel").style.display = "none";
        currentSelection = null;
      }

      function renderPersonProfileList(resp) {
        const root = document.getElementById("person-profile-list-root");
        const meta = document.getElementById("person-profile-list-meta");
        if (!root || !meta) return;

        const items = resp.items || [];
        const page = Number(resp.page || 1);
        const pageSize = Number(resp.page_size || 20);
        const total = Number(resp.total || 0);
        const totalPages = Math.max(1, Math.ceil(total / Math.max(1, pageSize)));
        const keyword = resp.keyword || "";

        window.personProfileListState = {
          page,
          pageSize,
          total,
          keyword,
        };

        meta.innerText = `å…³é”®è¯: ${keyword || "(å…¨éƒ¨)"} | ç¬¬ ${page}/${totalPages} é¡µ | æ€»æ•°: ${total}`;

        if (!items.length) {
          root.innerHTML =
            '<div style="font-size: 0.8rem; color: var(--text-dim); text-align: center; padding: 8px">æš‚æ— äººç‰©</div>';
          return;
        }

        root.innerHTML = items
          .map((item) => {
            const name = escapeHtml(item.display_name || item.person_id || "æœªçŸ¥");
            const pidRaw = item.person_id || "";
            const pid = escapeHtml(pidRaw);
            const pidEncoded = encodeURIComponent(pidRaw);
            const nick = escapeHtml(item.nickname || "");
            const aliasCount = Array.isArray(item.aliases) ? item.aliases.length : 0;
            const flagSnapshot = item.has_snapshot ? "S" : "-";
            const flagOverride = item.has_override ? "M" : "-";
            return `
              <div class="list-item" style="cursor: pointer; margin-bottom: 6px;" onclick="pickPersonProfileCandidate('${pidEncoded}')">
                <div style="font-weight: 600; color: var(--text-main);">${name}</div>
                <div style="font-size: 0.72rem; color: var(--text-dim); margin-top: 2px;">
                  id=${pid} | nick=${nick || "-"} | aliases=${aliasCount} | flags=${flagSnapshot}/${flagOverride}
                </div>
              </div>
            `;
          })
          .join("");
      }

      async function loadPersonProfileList(page = 1) {
        const root = document.getElementById("person-profile-list-root");
        if (!root) return;

        const keywordEl = document.getElementById("person-profile-keyword");
        const state = window.personProfileListState || {
          page: 1,
          pageSize: 20,
          total: 0,
          keyword: "",
        };
        const keyword = (keywordEl ? keywordEl.value.trim() : state.keyword) || "";

        try {
          root.innerHTML =
            '<div style="font-size: 0.8rem; color: var(--text-dim); text-align: center; padding: 8px">åŠ è½½ä¸­...</div>';
          const res = await axios.get("/api/person_profile/list", {
            params: {
              keyword: keyword,
              page: page,
              page_size: state.pageSize || 20,
            },
          });
          renderPersonProfileList(res.data || {});
        } catch (err) {
          const msg = err.response?.data?.detail || err.message || "æœªçŸ¥é”™è¯¯";
          root.innerHTML = `<div style="font-size: 0.8rem; color: rgba(239, 68, 68, 0.9); padding: 8px">åŠ è½½å¤±è´¥: ${escapeHtml(msg)}</div>`;
        }
      }

      function prevPersonProfilePage() {
        const state = window.personProfileListState || { page: 1 };
        const prev = Math.max(1, Number(state.page || 1) - 1);
        loadPersonProfileList(prev);
      }

      function nextPersonProfilePage() {
        const state = window.personProfileListState || { page: 1, pageSize: 20, total: 0 };
        const page = Number(state.page || 1);
        const totalPages = Math.max(1, Math.ceil(Number(state.total || 0) / Math.max(1, Number(state.pageSize || 20))));
        const next = Math.min(totalPages, page + 1);
        loadPersonProfileList(next);
      }

      function pickPersonProfileCandidate(personIdEncoded) {
        const personId = decodeURIComponent(personIdEncoded || "");
        const keywordEl = document.getElementById("person-profile-keyword");
        if (keywordEl) keywordEl.value = personId || "";
        queryPersonProfile(false, personId || "");
      }

      function formatUnixSeconds(sec) {
        if (!sec) return "-";
        const n = Number(sec);
        if (!Number.isFinite(n) || n <= 0) return "-";
        return new Date(n * 1000).toLocaleString();
      }

      function renderPersonProfileResult(data) {
        const metaEl = document.getElementById("person-profile-meta");
        const autoEl = document.getElementById("person-profile-auto");
        const overrideEl = document.getElementById("person-profile-override");
        const mergedEl = document.getElementById("person-profile-merged");
        const keywordEl = document.getElementById("person-profile-keyword");
        if (!metaEl || !autoEl || !overrideEl || !mergedEl) return;

        const personId = data.person_id || "";
        const personName = data.person_name || "-";
        const profileVersion = data.profile_version || "-";
        const fromCache = data.from_cache ? "æ˜¯" : "å¦";
        const source = data.profile_source || "auto_snapshot";
        const hasManual = data.has_manual_override ? "æ˜¯" : "å¦";

        metaEl.innerText =
          `person_id: ${personId} | åç§°: ${personName} | ç‰ˆæœ¬: ${profileVersion}\n` +
          `æ¥æº: ${source} | ç¼“å­˜: ${fromCache} | æ‰‹å·¥è¦†ç›–: ${hasManual}\n` +
          `æ›´æ–°æ—¶é—´: ${formatUnixSeconds(data.updated_at)} | è¦†ç›–æ›´æ–°æ—¶é—´: ${formatUnixSeconds(data.override_updated_at)}`;

        autoEl.value = data.auto_profile_text || data.profile_text || "";
        overrideEl.value = data.manual_override_text || "";
        mergedEl.value = data.profile_text || "";
        if (keywordEl && personId) keywordEl.value = personId;
        window.currentPersonProfile = data;
      }

      async function queryPersonProfile(forceRefresh = false, explicitPersonId = "") {
        const keywordEl = document.getElementById("person-profile-keyword");
        if (!keywordEl) return;

        const raw = explicitPersonId || keywordEl.value.trim();
        if (!raw) {
          showToast("è¯·è¾“å…¥äººç‰©IDæˆ–åç§°");
          return;
        }

        const payload = {
          force_refresh: !!forceRefresh,
          top_k: 12,
        };
        if (/^[0-9a-fA-F]{32}$/.test(raw)) payload.person_id = raw;
        else payload.person_keyword = raw;

        try {
          const res = await axios.post("/api/person_profile/query", payload);
          renderPersonProfileResult(res.data || {});
          showToast("äººç‰©ç”»åƒå·²åŠ è½½");
        } catch (err) {
          const msg = err.response?.data?.detail || err.message || "æœªçŸ¥é”™è¯¯";
          showToast(`ç”»åƒæŸ¥è¯¢å¤±è´¥: ${msg}`);
        }
      }

      async function savePersonProfileOverride() {
        const overrideEl = document.getElementById("person-profile-override");
        if (!overrideEl) return;

        const current = window.currentPersonProfile || {};
        const personId = (current.person_id || "").trim();
        if (!personId) {
          showToast("è¯·å…ˆæŸ¥è¯¢äººç‰©ç”»åƒ");
          return;
        }

        try {
          const res = await axios.post("/api/person_profile/override", {
            person_id: personId,
            override_text: overrideEl.value || "",
            updated_by: "webui",
          });
          if (res.data?.profile?.success) {
            renderPersonProfileResult(res.data.profile);
          } else {
            await queryPersonProfile(false, personId);
          }
          showToast("ç”»åƒä¿®è®¢å·²ä¿å­˜");
        } catch (err) {
          const msg = err.response?.data?.detail || err.message || "æœªçŸ¥é”™è¯¯";
          showToast(`ä¿å­˜å¤±è´¥: ${msg}`);
        }
      }

      async function clearPersonProfileOverride() {
        const current = window.currentPersonProfile || {};
        const personId = (current.person_id || "").trim();
        if (!personId) {
          showToast("è¯·å…ˆæŸ¥è¯¢äººç‰©ç”»åƒ");
          return;
        }
        if (!confirm("ç¡®è®¤æ¸…é™¤æ­¤äººç‰©çš„æ‰‹å·¥ä¿®è®¢ç”»åƒï¼Ÿ")) return;

        try {
          await axios.delete("/api/person_profile/override", {
            data: { person_id: personId },
          });
          await queryPersonProfile(false, personId);
          showToast("å·²æ¸…é™¤æ‰‹å·¥ä¿®è®¢");
        } catch (err) {
          const msg = err.response?.data?.detail || err.message || "æœªçŸ¥é”™è¯¯";
          showToast(`æ¸…é™¤å¤±è´¥: ${msg}`);
        }
      }

      // --- Event Handlers ---

      function onNodeClick(nodeId) {
        currentSelection = { type: "node", data: nodeId };
        openPanel("node-editor", nodeId);
      }

      function onEdgeClick(edgeId) {
        const edge = edges.get(edgeId);
        currentSelection = { type: "edge", data: edge };
        openPanel("edge-editor", edge);
      }

      async function manualSave() {
        showToast("åŒæ­¥æŒä¹…åŒ–å±‚...");
        try {
          const res = await axios.post("/api/save");
          showToast("âœ… æŒä¹…åŒ–å®Œæˆ: " + res.data.saved.join(", "));
        } catch (err) {
          showToast("âŒ åŒæ­¥å¤±è´¥");
        }
      }

      // --- Actions ---

      async function renameNode() {
        const oldId = currentSelection.data;
        const newId = document.getElementById("rename-input").value.trim();
        if (!newId) return showToast("è¯·è¾“å…¥åç§°");
        try {
          const pos = network.getPositions([oldId])[oldId];
          await axios.put("/api/node/rename", { old_id: oldId, new_id: newId });
          showToast("ä¿®è®¢æˆåŠŸ");

          // Optimistically update or just reload. Since loadData is now incremental,
          // re-fetching is safe.
          await loadData();
          closePanel();
          if (nodes.get(newId)) {
            focusNode(newId);
          }
        } catch (e) {
          showToast("æ“ä½œå¼‚å¸¸");
        }
      }

      async function deleteNode() {
        const nodeId = currentSelection.data;
        if (!confirm(`ç¡®è®¤ä»å…¨å±€å…¨æ™¯ä¸­å‰¥ç¦»å®ä½“ "${nodeId}"ï¼Ÿ`)) return;
        try {
          await axios.delete("/api/node", { data: { node_id: nodeId } });
          showToast("å·²å‰¥ç¦»");
          nodes.remove(nodeId);
          closePanel();
        } catch (e) {
          showToast("å‰¥ç¦»å¤±è´¥");
        }
      }

      async function saveEdge() {
        const edge = currentSelection.data;
        const weight = parseFloat(
          document.getElementById("weight-slider").value,
        );
        try {
          await axios.post("/api/edge/weight", {
            source: edge.from,
            target: edge.to,
            weight,
          });
          showToast("æƒé‡åˆ·æ–°å®Œæˆ");
          edges.update({ ...edge, value: weight });
        } catch (e) {
          showToast("ç½‘ç»œå¼‚å¸¸");
        }
      }

      async function deleteEdge() {
        const edge = currentSelection.data;
        if (!confirm("ç¡®å®šåˆ‡æ–­æ­¤æ˜ å°„è¿æ¥ï¼Ÿ")) return;
        try {
          await axios.delete("/api/edge", {
            data: { source: edge.from, target: edge.to },
          });
          showToast("è¿æ¥å·²åˆ‡æ–­");
          edges.remove(edge.id);
          closePanel();
        } catch (e) {
          showToast("æ“ä½œå¤±è´¥");
        }
      }

      async function addNode() {
        const name = document.getElementById("new-node-name").value.trim();
        if (!name) return;
        try {
          await axios.post("/api/node", { node_id: name });
          showToast("å®ä½“å·²åŒæ­¥");
          loadData();
          closePanel();
        } catch (e) {
          showToast("åŒæ­¥å¼‚å¸¸");
        }
      }

      async function addEdge() {
        const source = document.getElementById("edge-source").value.trim();
        const target = document.getElementById("edge-target").value.trim();
        const predicate = document
          .getElementById("edge-predicate")
          .value.trim();
        if (!source || !target) return;
        try {
          await axios.post("/api/edge", {
            source,
            target,
            weight: 1.0,
            predicate,
          });
          showToast("å…³ç³»å±‚å·²å°±ç»ª");
          loadData();
          closePanel();
        } catch (e) {
          showToast("å»ºç«‹å¤±è´¥");
        }
      }

      async function submitQuickRelation() {
        const cur = currentSelection.data;
        const tgt = document.getElementById("quick-target").value.trim();
        const pre = document.getElementById("quick-predicate").value.trim();
        if (!tgt) return;
        try {
          await axios.post("/api/edge", {
            source: cur,
            target: tgt,
            weight: 1.0,
            predicate: pre,
          });
          showToast("å¿«é€Ÿå…³è”æˆåŠŸ");
          loadData();
          renderNodeRelations(cur);
        } catch (e) {
          showToast("å¤±è´¥");
        }
      }

      // --- Simulation Control ---

      function toggleSimulation() {
        if (!network) return;
        if (isSimulationRunning) {
          network.setOptions({ physics: { enabled: false } }); // Strong pause
          isSimulationRunning = false;
          showToast("ç‰©ç†æ¨¡æ‹Ÿå·²æš‚åœ");

          // Clear any pending freeze timer if user manually pauses
          if (_freezeTimer) {
            clearTimeout(_freezeTimer);
            _freezeTimer = null;
          }
        } else {
          // Re-enable physics with sensible defaults for manual trigger
          network.setOptions({
            physics: {
              enabled: true,
              solver: "barnesHut",
              barnesHut: {
                gravitationalConstant: -5000,
                centralGravity: 0.005, // Very low to prevent collapse
                springLength: 200,
                avoidOverlap: 0.5
              }
            }
          });
          network.startSimulation();
          isSimulationRunning = true;
          showToast("ç‰©ç†æ¨¡æ‹Ÿç»§ç»­ (å¯éšæ—¶æš‚åœ)");
          
          // Auto-freeze after a while for large graphs
          if (_freezeTimer) clearTimeout(_freezeTimer);
          _freezeTimer = setTimeout(() => {
            if (network && isSimulationRunning) {
              network.stopSimulation();
              isSimulationRunning = false;
              updateSimBtnEnv();
              showToast("å·²è‡ªåŠ¨å†»ç»“å¸ƒå±€");
            }
          }, 8000);
        }
        updateSimBtnEnv();
      }

      function updateSimBtnEnv() {
        const icon = document.getElementById("sim-btn-icon");
        const text = document.getElementById("sim-btn-text");
        if (isSimulationRunning) {
          icon.innerText = "â¸ï¸";
          text.innerText = "æš‚åœæ¨¡æ‹Ÿ";
        } else {
          icon.innerText = "â–¶ï¸";
          text.innerText = "ç»§ç»­å¸ƒå±€";
        }
      }

      function applyAdaptiveSettings(complexity, nodeCount) {
        // Default (Small)
        let mode = "SMALL";

        if (complexity > 600) mode = "LARGE";
        else if (complexity > 300) mode = "MEDIUM";

        console.log(
          `[Perf] Complexity: ${complexity} (Nodes: ${nodeCount}), Mode: ${mode}`,
        );

        if (mode === "SMALL") {
          setLowPerfMode(false);
          if (network) {
            network.setOptions({
              physics: {
                enabled: isSimulationRunning,
                solver: "forceAtlas2Based",
                stabilization: { enabled: isSimulationRunning, iterations: 200 },
                forceAtlas2Based: {
                  theta: 0.5,
                  gravitationalConstant: -50,
                  springLength: 100,
                },
              },
              nodes: { font: { size: 14 } }, // Restore font
            });
          }
        } else if (mode === "MEDIUM") {
          setLowPerfMode(true);
          if (network) {
            network.setOptions({
              physics: {
                enabled: isSimulationRunning,
                solver: "forceAtlas2Based",
                // è¿­ä»£æ¬¡æ•°è¾ƒé«˜ï¼Œä½†åˆ†å¸§æ‰§è¡Œä»¥é¿å…æµè§ˆå™¨å‡æ­»
                stabilization: {
                  enabled: isSimulationRunning,
                  iterations: 1000,
                  updateInterval: 50,
                  onlyDynamicEdges: false,
                },
              },
              nodes: { font: { size: 14 } },
            });
          }
          // Only toast if not already in that mode to avoid spam
          // But since loadData usually happens on manual refresh or significant change, toast is fine.
          showToast(`ğŸš€ ä¸­è§„æ¨¡æ•°æ®: å·²å¯ç”¨åˆ†å¸§æ¸²æŸ“`);
        } else if (mode === "LARGE") {
          setLowPerfMode(true);
          if (network) {
            // For very large graphs: DISABLE physics entirely
            // User can re-enable via "Continue Layout" button
            network.setOptions({
              physics: { enabled: false },
              nodes: { font: { size: 0 } }, // Label Degradation
            });
            
            // Stop simulation immediately
            network.stopSimulation();
            isSimulationRunning = false;
            updateSimBtnEnv();
          }
          showToast(`âš¡ å¤§è§„æ¨¡æ•°æ® (${nodeCount}èŠ‚ç‚¹): ç‰©ç†å·²ç¦ç”¨ï¼Œç‚¹å‡»"ç»§ç»­å¸ƒå±€"å¯å¯ç”¨`);

          // Clear any pending freeze timer
          if (_freezeTimer) {
            clearTimeout(_freezeTimer);
            _freezeTimer = null;
          }
        }
      }

      // --- å·¥å…·å‡½æ•° (Utils) ---

      function hexToRgba(hex, alpha) {
        let c;
        if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
          c = hex.substring(1).split("");
          if (c.length === 3) {
            c = [c[0], c[0], c[1], c[1], c[2], c[2]];
          }
          c = "0x" + c.join("");
          return (
            "rgba(" +
            [(c >> 16) & 255, (c >> 8) & 255, c & 255].join(",") +
            "," +
            alpha +
            ")"
          );
        }
        return hex;
      }

      // --- æ•°æ®æ‹‰å–è¾…åŠ© (Fetch Helpers) ---

      async function fetchSources(params, rootId) {
        const root = document.getElementById(rootId);
        root.innerHTML =
          '<div style="color: var(--text-dim); font-size: 0.8rem;">æ­£åœ¨è¿½æº¯è®°å¿†æ¥æº...</div>';
        try {
          const res = await axios.post("/api/source/list", params);
          const sources = res.data.sources;
          if (!sources || sources.length === 0) {
            root.innerHTML =
              '<div style="color: var(--text-dim); font-size: 0.8rem;">[ æœªå‘ç°ç›´æ¥è®°å¿†æº¯æº ]</div>';
            return;
          }
          let html =
            '<div style="font-size: 0.8rem; color: var(--text-dim); margin-bottom: 12px; border-top: 1px solid var(--glass-border); padding-top: 15px;">ğŸ“š çŸ¥è¯†æº¯æº</div>';
          sources.forEach((s) => {
            html += `
                        <div class="list-item">
                            <div style="font-size: 0.85rem; color: white;">${escapeHtml(s.content)}</div>
                            <div style="font-size: 0.7rem; color: var(--accent-secondary); margin-top: 6px;">æ¥è‡ª: ${s.source}</div>
                        </div>
                    `;
          });
          root.innerHTML = html;
        } catch (e) {
          root.innerHTML = "";
        }
      }

      function renderNodeRelations(nodeId) {
        const connectedEdges = edges.get({
          filter: (item) => item.from === nodeId || item.to === nodeId,
        });
        const root = document.getElementById("relations-list-root");
        if (connectedEdges.length === 0) {
          root.innerHTML = "";
          return;
        }

        let html =
          '<div style="font-size: 0.8rem; color: var(--text-dim); margin-bottom: 12px; border-top: 1px solid var(--glass-border); padding-top: 15px;">ğŸ”— èŠ‚ç‚¹æ‹“æ‰‘</div>';
        connectedEdges.forEach((e) => {
          const isOut = e.from === nodeId;
          const other = isOut ? e.to : e.from;
          html += `
                    <div class="list-item" style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="cursor: pointer; display: flex; align-items: center;" onclick="focusNode('${other}')" title="è·³è½¬è‡³è¯¥å®ä½“">
                            <span style="color: ${isOut ? "var(--accent-primary)" : "var(--accent-secondary)"}; font-weight: 600;">${isOut ? "â”" : "â†"}</span>
                            <span style="margin-left: 8px; font-size: 0.85rem; border-bottom: 1px dashed rgba(255,255,255,0.3);">${other}</span>
                        </div>
                        <span style="color: var(--text-dim); font-size: 0.75rem;">${e.label || "-"}</span>
                    </div>
                `;
        });
        root.innerHTML = html;
      }

      async function loadSourceFiles() {
        const root = document.getElementById("source-files-list");
        root.innerHTML = "åŠ è½½ä¸­...";
        try {
          const res = await axios.post("/api/source/list", {});
          const sources = res.data.sources;

          // ç­›é€‰çŠ¶æ€æ˜¾ç¤º (Filter status display)
          let header = "";
          if (currentSource) {
            header = `<div style="padding: 10px; background: rgba(56, 189, 248, 0.2); border-radius: 8px; margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;">
                        <span>ğŸ” å½“å‰èšç„¦: <b>${currentSource}</b></span>
                        <button class="btn btn-ghost" style="padding: 4px 10px; font-size: 0.8rem;" onclick="setSourceFilter(null)">é‡ç½® / æŸ¥çœ‹å…¨éƒ¨</button>
                    </div>`;
          }

          const listHtml = sources
            .map(
              (f) => `
                    <div class="list-item" style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; margin-right: 15px;">
                            <div style="font-size: 0.9rem; color: ${currentSource === f.source ? "var(--accent-primary)" : "white"};">${f.source}</div>
                            <div style="font-size: 0.7rem; color: var(--text-dim);">${f.count} æ®µè®°å¿†è®°å½•</div>
                        </div>
                        <div style="display: flex; gap: 6px;">
                            <button class="btn btn-ghost" style="padding: 4px 8px;" onclick="setSourceFilter('${f.source}')" title="èšç„¦æ­¤æ‰¹æ¬¡">ğŸ‘ï¸</button>
                            <button class="btn btn-danger" style="padding: 4px 8px;" onclick="deleteSourceFile('${f.source}')" title="åˆ é™¤">ğŸ—‘ï¸</button>
                        </div>
                    </div>
                `,
            )
            .join("");

          root.innerHTML = header + listHtml;
        } catch (e) {
          root.innerHTML = "åŠ è½½å¤±è´¥";
        }
      }

      function setSourceFilter(source) {
        currentSource = source;
        loadData();
        loadSourceFiles(); // Refresh UI
        if (source) showToast(`å·²èšç„¦æ‰¹æ¬¡: ${source}`);
        else showToast("å·²é‡ç½®è§†å›¾");
      }

      async function deleteSourceFile(src) {
        if (
          !confirm(
            `å±é™©ï¼šä¸€æ—¦æ“¦é™¤ "${src}"ï¼Œæ‰€æœ‰ç›¸å…³çš„å…³è”ä¸è®°å¿†å°†æ°¸ä¹…æ¶ˆå¤±ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ`,
          )
        )
          return;
        try {
          await axios.post("/api/source/batch_delete", { source: src });
          showToast("å·²å®Œæˆè®°å¿†æ“¦é™¤");
          loadSourceFiles();
          loadData();
        } catch (e) {
          showToast("æ“¦é™¤å¤±è´¥");
        }
      }

      async function toggleAutoSave(enabled) {
        try {
          await axios.post("/api/config/auto_save", { enabled });
          showToast(enabled ? "è‡ªåŠ¨ä¿å­˜æ¿€æ´»" : "è‡ªåŠ¨ä¿å­˜å·²æŒ‚èµ·");
        } catch (e) {
          showToast("è®¾ç½®å¤±è´¥");
        }
      }

      // --- Helpers ---

      function highlightNeighborhood(nodeId) {
        if (!nodeId) return;
        isHighlighting = true;

        const allNodes = nodes.get();
        const allEdges = edges.get();

        // 1. Find neighbors
        const degree1 = network.getConnectedNodes(nodeId);
        const degree2 = [];
        degree1.forEach((id) => {
          degree2.push(...network.getConnectedNodes(id));
        });

        const mainSet = new Set([nodeId]);
        const d1Set = new Set(degree1);
        const d2Set = new Set(degree2);

        // Get current theme config
        const themeName = THEMES[currentThemeIdx];
        const cfg = THEME_CONFIG[themeName];

        // 2. åº”ç”¨é€æ˜åº¦æ§åˆ¶ (Apply opacity)
        // Vis.js å¯¹æ‰€æœ‰å½¢çŠ¶ç›´æ¥æ”¯æŒé€æ˜åº¦å±æ€§å¹¶ä¸å®¹æ˜“ï¼ˆé™¤éä½¿ç”¨ RGBAï¼‰ã€‚
        // æˆ‘ä»¬ä½¿ç”¨æ›´ç®€å•çš„æ–¹æ³•ï¼šè°ƒæ•´é¢œè‰²çš„ alpha å€¼ã€‚
        const hexToRgba = (hex, alpha) => {
          // Assuming hex is #RRGGBB
          if (!hex) return `rgba(128, 128, 128, ${alpha})`; // Neutral fallback
          const r = parseInt(hex.slice(1, 3), 16);
          const g = parseInt(hex.slice(3, 5), 16);
          const b = parseInt(hex.slice(5, 7), 16);
          return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        };

        const finalNodes = allNodes.map((n) => {
          let opacity = 0.1;
          let color = n.color
            ? typeof n.color === "string"
              ? n.color
              : n.color.background
            : cfg.node.background;
          let showLabel = n.isHub; // Default

          // æ£€æŸ¥é›†åˆ (é¡ºåºå¾ˆé‡è¦ï¼šé€‰ä¸­ -> ä¸€åº¦é‚»å±… -> äºŒåº¦é‚»å±…)
          if (mainSet.has(n.id)) {
            opacity = 1.0;
            showLabel = true;
          } else if (d1Set.has(n.id)) {
            opacity = 0.8;
            showLabel = true;
          } else if (d2Set.has(n.id)) {
            opacity = 0.3;
            showLabel = true;
          }

          // Define vars for reuse
          const alpha = opacity;
          const baseColor = cfg.node.background;
          const borderColor = cfg.node.border;

          // Adjust font color alpha (using the theme font color as base)
          // Note: simple alpha append for hex font color isn't trivial without helper,
          // but we can assume font is hex and use hexToRgba.
          const fontBase = cfg.node.font;

          return {
            id: n.id,
            opacity: opacity,
            label: showLabel ? n.hiddenLabel : " ",
            color: {
              background: hexToRgba(baseColor, alpha),
              border: hexToRgba(borderColor, alpha),
            },
            font: { color: hexToRgba(fontBase, alpha) },
          };
        });

        const finalEdges = allEdges.map((e) => {
          let alpha = 0.05;
          const connectedToMain = mainSet.has(e.from) || mainSet.has(e.to);
          const connectedToD1 = d1Set.has(e.from) || d1Set.has(e.to);

          if (connectedToMain) alpha = 0.8;
          else if (connectedToD1) alpha = 0.2;

          // ä½¿ç”¨ä¸»é¢˜è¾¹é¢œè‰² (Use theme edge colors)
          // Extract R,G,B from theme edge color?
          // Theme edge color is usually rgba... e.g. 'rgba(148, 163, 184, 0.4)'
          // Complexity: parsing the rgba string from config to change alpha.
          // Shortcuts: The theme defines a base color, we should use that base but modify alpha.
          // For simplicity, let's use a standard gray-ish for edges in all themes OR parse.
          // Let's use specific dim colors based on theme if possible, or just the hardcoded gray which works generally well.
          // BETTER: Use `cfg.edge.color` but replace alpha.

          // Quick hack: Just use the hardcoded gray/slate for edges as they are distinct enough,
          // OR adapt to light mode (needs dark edges).

          let edgeBase = "148, 163, 184"; // Default Slate 400
          if (themeName === "light") edgeBase = "100, 116, 139"; // Slate 500 (Darker)
          if (themeName === "neon") edgeBase = "217, 70, 239"; // Pinkish

          const edgeColor = `rgba(${edgeBase}, ${alpha})`;

          return {
            id: e.id,
            color: { color: edgeColor, highlight: cfg.edge.highlight },
            font: {
              color: edgeColor,
              strokeWidth: 0,
              background: "transparent",
            },
            dashes: e.dashes, // Preserve dashes status
            shadow: e.shadow  // Preserve shadow status
          };
        });

        nodes.update(finalNodes);
        edges.update(finalEdges);
      }

      function resetHighlight() {
        if (!isHighlighting) return;
        isHighlighting = false;

        const allNodes = nodes.get();
        const allEdges = edges.get();
        const zoomedIn = isZoomedIn();

        const themeName = THEMES[currentThemeIdx];
        const cfg = THEME_CONFIG[themeName];

        const resetNodes = allNodes.map((n) => {
          let shouldShow = n.isHub;
          if (zoomedIn) {
            const pos = network.getPositions([n.id])[n.id];
            if (pos) {
              const domPos = network.canvasToDOM(pos);
              const rect = network.canvas.frame.getBoundingClientRect();
              if (
                domPos.x >= 0 &&
                domPos.x <= rect.width &&
                domPos.y >= 0 &&
                domPos.y <= rect.height
              ) {
                shouldShow = true;
              }
            }
          }

          // åº”ç”¨å¹½çµ (éæ´»è·ƒ) æˆ–åˆ é™¤æ ·å¼ (Apply Ghost or Deleted styling)
          let nodeOpacity = n.is_ghost ? 0.2 : 1.0;
          let fontColor = cfg.node.font;
          
          let bgColor = cfg.node.background;
          let borderColor = cfg.node.border;
          
          if (n.is_ghost) {
               fontColor = hexToRgba(cfg.node.font, 0.4);
          }
          
          if (n.is_deleted) {
               bgColor = '#ef4444'; // Red
               borderColor = '#b91c1c';
               fontColor = '#ffffff';
               nodeOpacity = 0.8;
          }

          return {
            id: n.id,
            opacity: nodeOpacity,
            label: shouldShow ? n.hiddenLabel : " ",
            color: {
              background: bgColor,
              border: borderColor,
              highlight: {
                background: bgColor, // Keep red on highlight
                border: borderColor,
              },
            },
            font: { color: fontColor },
          };
        });

        const resetEdges = allEdges.map((e) => {
            // åº”ç”¨ V5 é€»è¾‘ (Apply V5 Logic)
            let color = cfg.edge.color;
            let dashes = false;
            let shadow = false;
            let width = 1;
            
            if (e.is_active === false) {
                 color = cfg.v5.inactive;
                 dashes = true;
            } else if (e.is_pinned || e.is_protected) {
                 width = 2;
                 const shadowColor = e.is_pinned ? cfg.v5.pinned : cfg.v5.protected;
                 shadow = { enabled: true, color: shadowColor, size: 5 };
            }

            return {
              id: e.id,
              color: { color: color, highlight: cfg.edge.highlight },
              font: { color: cfg.edge.color, background: "transparent" },
              dashes: dashes,
              width: width,
              shadow: shadow
            };
        });

        nodes.update(resetNodes);
        edges.update(resetEdges);
      }

      function focusNode(nodeId) {
        network.selectNodes([nodeId]);
        network.focus(nodeId, {
          scale: 1.0,
          animation: { duration: 500, easingFunction: "easeInOutQuad" },
        });
        onNodeClick(nodeId);
      }

      function searchNode() {
        // Legacy/Fallback
        handleSearchInput(document.getElementById("node-search-input").value);
      }

      // --- æ–°çš„æœç´¢ä¸æµè§ˆå™¨é€»è¾‘ (New Search & Browser Logic) ---

      function handleSearchInput(val) {
        const container = document.getElementById("search-results");
        if (!val || !val.trim()) {
          container.style.display = "none";
          return;
        }

        val = val.toLowerCase();
        const all = nodes.get();
        const matches = all
          .filter((n) => {
            const label = n.hiddenLabel || n.label || "";
            return (
              label.toLowerCase().includes(val) ||
              n.id.toLowerCase().includes(val)
            );
          })
          .slice(0, 10);

        if (matches.length === 0) {
          container.innerHTML =
            '<div style="padding:10px; color:var(--text-dim); text-align:center">æ— åŒ¹é…ç»“æœ</div>';
        } else {
          container.innerHTML = matches
            .map((n) => {
              const displayLabel = n.hiddenLabel || n.label || n.id;
              return `
                <div class="search-item" onclick="selectSearchResult('${n.id}')">
                    <span>${displayLabel}</span>
                    <span style="font-size:0.7rem; color:var(--text-dim)">${n.isHub ? "æ ¸å¿ƒ" : "èŠ‚ç‚¹"}</span>
                </div>
              `;
            })
            .join("");
        }
        container.style.display = "block";
      }

      function hideSearchResults() {
        document.getElementById("search-results").style.display = "none";
      }

      function selectSearchResult(id) {
        focusNode(id);
        const node = nodes.get(id);
        document.getElementById("node-search-input").value =
          node.hiddenLabel || node.label || node.id;
        hideSearchResults();
      }

      // çŸ¥è¯†å­—å…¸æµè§ˆå™¨é¢æ¿ (Browser Panel)
      window.currentBrowserTab = "nodes";

      function switchBrowserTab(tab) {
        window.currentBrowserTab = tab;
        // Update UI tabs
        const tabs = document.querySelectorAll(".browser-tab");
        tabs.forEach((t) => t.classList.remove("active"));
        if (tab === "nodes") tabs[0].classList.add("active");
        else tabs[1].classList.add("active");

        renderBrowserContent();
      }

      function renderBrowserContent() {
        const root = document.getElementById("browser-content-root");
        const filter = document
          .getElementById("browser-filter")
          .value.toLowerCase();
        const tab = window.currentBrowserTab;

        root.innerHTML = "";

        // Collect items
        let items = [];
        if (tab === "nodes") {
          items = nodes.get().map((n) => {
            const label = n.hiddenLabel || n.label || n.id;
            return {
              sortKey: label.toUpperCase(),
              display: label,
              data: n,
            };
          });
        } else {
          items = edges.get().map((e) => ({
            sortKey: `${e.from} -> ${e.to}`.toUpperCase(),
            display: `${e.from} -> ${e.to}`,
            sub: e.label,
            data: e,
          }));
        }

        // Filter
        if (filter) {
          items = items.filter(
            (i) =>
              i.display.toLowerCase().includes(filter) ||
              (i.sub && i.sub.toLowerCase().includes(filter)),
          );
        }

        // Sort
        items.sort((a, b) => a.sortKey.localeCompare(b.sortKey));

        // Group (A-Z, #)
        const groups = {};
        items.forEach((item) => {
          let firstChar = item.sortKey.charAt(0);
          if (!/[A-Z]/.test(firstChar)) firstChar = "#";
          if (!groups[firstChar]) groups[firstChar] = [];
          groups[firstChar].push(item);
        });

        // Render
        Object.keys(groups)
          .sort()
          .forEach((key) => {
            const groupItems = groups[key];
            if (key === "#") return; // Render # last

            root.innerHTML += `<div class="group-header">${key}</div><div class="group-content">
                    ${groupItems.map((item) => renderBrowserItem(item, tab)).join("")}
                </div>`;
          });

        if (groups["#"]) {
          root.innerHTML += `<div class="group-header">#</div><div class="group-content">
                    ${groups["#"].map((item) => renderBrowserItem(item, tab)).join("")}
                </div>`;
        }
      }

      function renderBrowserItem(item, tab) {
        if (tab === "nodes") {
          return `
                <div class="list-item" style="cursor: pointer; margin-bottom: 4px;" onclick="focusNode('${item.data.id}')">
                    <div style="font-weight: 500;">${item.display}</div>
                </div>`;
        } else {
          return `
                <div class="list-item" style="cursor: pointer; margin-bottom: 4px;" onclick="selectEdge('${item.data.id}')">
                    <div style="font-size: 0.85rem;">${item.display}</div>
                    <div style="font-size: 0.75rem; color: var(--accent-secondary);">${item.sub || ""}</div>
                </div>`;
        }
      }

      function selectEdge(id) {
        const edge = edges.get(id);
        if (edge) {
          // Select and open panel
          network.selectEdges([id]);
          onEdgeClick(id);
          // Also focus camera on source node ? No, usually just selecting is enough.
          // But edge might be far away. Let's focus on from node.
          network.focus(edge.from, { scale: 1.0, animation: true });
        }
      }

      function showToast(msg, duration = 3000) {
        const t = document.getElementById("toast");
        t.innerText = msg;
        t.style.display = "block";
        setTimeout(() => (t.style.display = "none"), duration);
      }

      function escapeHtml(text) {
        const map = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#039;",
        };
        return text.replace(/[&<>"']/g, (m) => map[m]);
      }

      // --- V5 è®°å¿†åŠŸèƒ½å‡½æ•° (V5 Memory Functions) ---

      async function restoreMemory(hash, type) {
          try {
             type = type || 'relation'; // fallback
             const res = await axios.post("/api/memory/restore", { hash, type });
             showToast("è®°å¿†æ¢å¤æˆåŠŸ");
             loadRecycleBin(); // Refresh list
             loadData(); // Refresh graph to show restored link (if nodes exist)
          } catch(err) {
             showToast("æ¢å¤å¤±è´¥: " + (err.response?.data?.detail || err.message));
          }
      }
      
      async function loadRecycleBin() {
          const root = document.getElementById("recycle-list-root");
          if(!root) return;
          root.innerHTML = '<div style="text-align:center; padding:20px; color:var(--text-dim)">åŠ è½½ä¸­...</div>';
          
          try {
              const res = await axios.get("/api/memory/recycle_bin?limit=50");
              const items = res.data.items || [];
              
              if(items.length === 0) {
                 root.innerHTML = '<div style="text-align:center; padding:20px; color:var(--text-dim)">æš‚æ— åˆ é™¤è®°å½•</div>';
                 return;
              }
              
              root.innerHTML = items.map(item => {
                  let displayHtml = '';
                  let typeIcon = '';
                  const itemType = item.type || 'relation'; // default
                  
                  if (itemType === 'entity') {
                      displayHtml = `<div style="font-size:0.9rem; font-weight:600; color:var(--text-main);">${escapeHtml(item.name)} <span style="font-size:0.75rem; color:#ef4444; border:1px solid #ef4444; border-radius:4px; padding:0 4px;">å®ä½“</span></div>`;
                  } else {
                      displayHtml = `
                          <div style="font-size:0.9rem; font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; color:var(--text-main);">${item.subject} â” ${item.object}</div>
                          <div style="font-size:0.75rem; color:var(--text-dim); margin-top:4px;">${item.predicate || 'å…³è”'}</div>`;
                  }
                  
                  return `
                  <div class="list-item" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; padding:10px; background:rgba(255,255,255,0.05); border-radius:8px;">
                      <div style="flex:1; overflow:hidden;">
                          ${displayHtml}
                          <div style="font-size:0.7rem; color:var(--text-dim); margin-top:2px;">åˆ äº: ${new Date(item.deleted_at * 1000).toLocaleString()}</div>
                      </div>
                      <button class="btn btn-ghost" style="padding:4px 8px; color:var(--accent-primary);" onclick="restoreMemory('${item.hash}', '${itemType}')" title="æ¢å¤">â™»ï¸</button>
                  </div>
              `}).join("");
          } catch(err) {
              root.innerHTML = `<div style="padding:10px; color:rgba(239, 68, 68, 0.8)">åŠ è½½å¤±è´¥: ${err.message}</div>`;
          }
      }

      async function reinforceEdge() {
         if(!window.viewedEdgeId) return;
         try {
             await axios.post("/api/memory/reinforce", { id: window.viewedEdgeId });
             showToast("è®°å¿†å¼ºåŒ–æˆåŠŸ");
             loadData();
         } catch(err) {
             showToast("æ“ä½œå¤±è´¥: " + (err.response?.data?.detail || err.message));
         }
      }

      async function protectEdge() {
         if(!window.viewedEdgeId) return;
         
         const edge = edges.get(window.viewedEdgeId);
         const isPinned = !!edge.is_pinned;
         const newPinState = !isPinned; // Toggle
         
         // Server logic: is_pinned = (data.type == "pin")
         const typeArg = newPinState ? "pin" : "unpin";
         
         try {
             await axios.post("/api/memory/protect", { 
                 id: window.viewedEdgeId, 
                 type: typeArg, 
                 duration: 0 
             });

             showToast(newPinState ? "è®°å¿†å·²ä¿æŠ¤ (Pinned)" : "ä¿æŠ¤å·²å–æ¶ˆ");
             loadData();
         } catch(err) {
             showToast("æ“ä½œå¤±è´¥: " + (err.response?.data?.detail || err.message));
         }
      }

      async function freezeEdge() {
         if(!window.viewedEdgeId) return;
         if(!confirm("ç¡®å®šè¦å†·å†»æ­¤è®°å¿†å—ï¼Ÿè¿™å°†ä½¿å…¶å˜ä¸ºéæ´»è·ƒçŠ¶æ€ (è™šçº¿æ˜¾ç¤º)ã€‚")) return;
         
         try {
             await axios.post("/api/memory/freeze", { id: window.viewedEdgeId });
             showToast("è®°å¿†å·²å†·å†»");
             loadData();
         } catch(err) {
             showToast("æ“ä½œå¤±è´¥: " + (err.response?.data?.detail || err.message));
         }
      }
    </script>
  </body>
</html>
